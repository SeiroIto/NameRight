---
title: "Woman's name right and marital records in the US"
author: "Seiro Ito"
date: "`r format(Sys.time(), '%Y年%m月%d日 %R')`"
output:
  tufte::tufte_html:
    citation_package: natbib
    toc: true
  pdf_document:
     latex_engine: xelatex
     fig_width: 7
     fig_height: 6
     fig_caption: true
header-includes:
    - \usepackage{amsmath}
    - \usepackage{amssymb}
    - \usepackage{amsfonts}
    - \usepackage{bookmark} 
    - \usepackage{natbib} 
    - \usepackage{xltxtra} 
    - \usepackage{zxjatype} 
    - \usepackage[ipa]{zxjafont} 
    - \usepackage{marginnote}
bibliography: c:/seiro/settings/Tex/seiro.bib
link-citations: yes
# c:\seiro\languages\R\R-4.2.1\bin\x64\Rscript.exe -e "path <- 'c:/data/NameRight/program/'; rmarkdown::render('c:/data/NameRight/program/DeStat_Tufte.Rmd')"
# setwd(path <- "c:/data/NameRight/"); rmarkdown::render("program/DeStat_Tufte.Rmd")
#### rmarkdown::render(paste0(path, "program/DeStat_Tufte.Rmd"), output_format = "pdf_document")
#### cd c:/data/NameRight/
#### git init
#### git config --global user.name "SeiroIto"
#### git remote add origin https://github.com/SeiroIto/NameRight.git  ## specify remote
#### git add c:/data/NameRight/program c:/data/NameRight/save   ## this adds 
#### git rm --cached -r c:/data/NameRight/source/  ## untrack files in source folder
#### git rm --cached -r c:/data/NameRight/program/clubSandwich-main/
#### git rm --cached -r c:/data/NameRight/program/cached/
#### git rm --cached -r c:/data/NameRight/save/*.qs
#### git rm --cached -r c:/data/NameRight/save/*.prn
#### git commit -am "initial commit"
#### git ls-tree -r main --name-only ## list all tracked files
#### git push -f origin main  ## push files to remote
#### if error with push fatal: the remote end hung up unexpectedly, run below
#### git config http.postBuffer 2000000000
#### git push -f origin main  ## push files to remote
---
<!-- Using 2 byte characters causes an error in dynamic deploy in Jekylle via git push. knitting works fine.
Error reading file /github/workspace/program0/DeStat_Tufte.Rnw: invalid byte sequence in UTF-8 
-->
<!-- This page is generated by the grunt doc task of the main branch! Don't edit it! -->
{% capture documentation %}
{% include documentation.md %}
{% endcapture %}
{{ documentation | markdownify }}

```{css, echo=F}
.SeiroBenign {
  background-color: #FFEBCD;
  padding: 0.5em; /*文字まわり（上下左右）の余白*/
  /* border: 1px solid yellow; */
  /* font-weight: bold; */
}
.SeiroLightGreen {
  background-color: #D0F0C0; /* Tea green */
  padding: 0.5em; /*文字まわり（上下左右）の余白*/
  font-family: Noto S	ans;
  /* border: 1px solid yellow; */
  /* font-weight: bold; */
}
```
```{r setup, include=FALSE} 
#### include = F <==> echo=F & results = F
library(tufte)
#### invalidate cache when the tufte version changes
knitr::opts_chunk$set(tidy = FALSE, cache.extra = packageVersion('tufte'), 
  margin_references = TRUE,
  # remove leading hashes in html output
  comment = "", class.source = "SeiroBenign", class.output = "SeiroLightGreen")
options(htmltools.dir.version = FALSE)
```
<!-- reading this file makes echo = F and results = F for reasons I don't understand -->
```{r option setting 1, eval = F, cache = F, child='c:/migrate/R/rmarkdownPreamble/rmarkdown_initial_option_setting_chunk.Rmd'}
```
```{r option setting 2, echo = F, cache = F, warning = F}
knitr::opts_knit$set(base.dir = path)
knitr::opts_chunk$set(
  fig.path=paste0(path, '/program/figure/'), 
  cache.path=paste0(path, '/program/cache/ReadData'), 
  cache = FALSE, echo = TRUE, results = 'markup', 
  tidy.opts=list(blank=FALSE, width.cutoff=40))
options(digits = 6, width = 80)
library(data.table)
library(qs)
pathprogram <- paste0(path, "program/");  
pathsource <- paste0(path, "source/")
pathsave <- paste0(path, "save/")
pathfigure <- paste0(pathprogram, "figure/")
pathsavefigure <- paste0(pathsave, "figure/")
dir.create(pathsave)
dir.create(pathsavefigure)
source("c:/seiro/settings/Rsetting/panel_estimator_functions.R")
source("c:/seiro/settings/Rsetting/functions.R")
source(paste0(pathprogram, "tabulate_est_IPUMS.R"))
```
```{css, echo=FALSE}
/* Define a margin before hX (header level X) element */
h1  {
  margin-top: 3ex;
  margin-bottom: 3ex;
  /* background: #c2edff; */ /*背景色*/
  padding: 0.5em;/*文字まわり（上下左右）の余白*/
}
h2  {
  margin-top: 2ex;
  margin-bottom: 2ex;
  padding: 0.5em;/*文字周りの余白*/
  color: #010101;/*文字色*/
  /* background: #eaf3ff; */ /*背景色*/
  /* border-bottom: solid 3px #516ab6; */ /*下線*/
}
```
\def\Perp{\mkern2mu\rotatebox[origin=c]{90}{$\models$}\mkern2mu}
\newcommand{\mpage}[2]{\begin{minipage}[t]{#1}#2\end{minipage}}
\newcommand{\cnvp}{\stackrel{p}{\longrightarrow}}
\newcommand{\cnvd}{\stackrel{d}{\longrightarrow}}
\newcommand{\bfV}{\mathbf{V}}
\newcommand{\bfX}{\mathbf{X}}
\newcommand{\bfx}{\mathbf{x}}
\newcommand{\bfa}{\mathbf{a}}
\newcommand{\bfb}{\mathbf{b}}
\newcommand{\bfp}{\mathbf{p}}
\newcommand{\bfs}{\mathbf{s}}
\newcommand{\bfz}{\mathbf{z}}
\newcommand{\E}{{\Large\varepsilon}}
\newcommand{\NU}{{\Large\nu}}
\newcommand{\0}{{\mathbf{0}}}
\newcommand{\bfalpha}{\boldsymbol{\alpha}}
\newcommand{\bfbeta}{\boldsymbol{\beta}}
\newcommand{\bfgamma}{\boldsymbol{\gamma}}
\newcommand{\bftheta}{\boldsymbol{\theta}}
\newcommand{\bfeta}{\boldsymbol{\eta}}
\newcommand{\bfmu}{\boldsymbol{\mu}}
\newcommand{\bflambda}{\boldsymbol{\lambda}}
\newcommand{\ind}{\mathrel{\perp\!\!\!\!\perp}}
\renewcommand{\thefootnote}{*\arabic{footnote}}

(US婚姻データの記述統計)  



\hfil Seiro Ito

\setcounter{tocdepth}{3}
\tableofcontents

\setlength{\parindent}{1em}
\vspace{2ex}


# Read marriage/divorce files

## NBER marriage data

```{r read files}
#### marriage
m2 <- qread(paste0(pathsave, "mar2.qs"))
setkey(m2, StateName, DateMarried)
m2[, .(StateName, DateMarried, race.g, agem.g, race.b, agem.b)]
m2[, YearMon := as.IDate(paste0(year, "-", month, "-01"), 
  format = "%Y-%m-%d")]
m2ym <- m2[, .(
    Mar=.N, 
    MedianAge.g = median(agem.g, na.rm = T), 
    MedianAge.b = median(agem.b, na.rm = T), YM=YearMon[1]),
  by = .(StateName, year, month)]
```

**Dunn v. Palermo** of Tennessee (April 7, 1975) and neighbouring states

```{r Tennessee Dunn v Palermo 1975}
library(ggplot2)
ThisTheme <-   theme(
  legend.position = "bottom", 
  legend.direction = "horizontal",
  legend.text=element_text(size=6),
  legend.key.size=unit(.25, "cm"),
  legend.title = element_blank()
  )
#### drop virginia "V.*a$" as it has a data problem
dunn <- m2ym[grepl("Ten|Ken|Missi|Ark|Alab|Geor|Nor.*C", StateName), ]
g <- ggplot(data = dunn, aes(x = YM, y = Mar, group = StateName, 
    shape = StateName, colour = StateName)) + 
  geom_point() +
  geom_line() +
  scale_y_log10() +
  scale_shape_manual(values = 0:10) +
  geom_vline(xintercept = as.IDate("1975-04-01", format = "%Y-%m-%d"), 
    colour = "red") + 
  scale_color_manual(values = c(
    "Alabama" = "lightblue", "Arkansas" = "lightblue", "Georgia" = "lightblue", 
    "Kentucky" = "lightblue", "Mississippi" = "lightblue", 
    "North Carolina" = "lightblue", "Tennessee" = "darkblue")) + ThisTheme +
  guides(colour=guide_legend(ncol=2, byrow=F))
pdf(
  paste0(pathsave, "NumberOfMarriagesDunnPalermo.pdf")
  , width = 14/2.54, height = 8/2.54)
print(g)
whatever <- dev.off()
```
```{r Tennessee Dunn v Palermo 1975 plot, echo = F, fig.cap = "Number of marriages: Tennessee and contiguous states before and after Dunn v. Palermo", fig.fullwidth = F}
ggplot(data = dunn, aes(x = YM, y = Mar, group = StateName, 
    shape = StateName, colour = StateName)) + 
  geom_point() +
  geom_line() +
  scale_y_log10() +
  scale_shape_manual(values = 0:10) +
  geom_vline(xintercept = as.IDate("1975-04-01", format = "%Y-%m-%d"), colour = "red") + 
  scale_color_manual(values = c(
  "Alabama" = "lightblue", "Arkansas" = "lightblue", "Georgia" = "lightblue", "Kentucky" = "lightblue",
  "Mississippi" = "lightblue", "North Carolina" = "lightblue", "Tennessee" = "darkblue")) + ThisTheme +
  guides(colour=guide_legend(ncol=2, byrow=F))
```

There is an obvious data problem with Tennessee in NBER data. The counts are almost halved after 1975. We cannot use it for analysis.
```{r Tennessee}
reshape(dunn[grepl("Tenn", StateName) & 1971 <= year & year <= 1976, 
  .(StateName, year, month, Mar)],
  direction = "wide", idvar = c("StateName", "month"), 
  timevar = "year", v.names = "Mar")
```

## NCH marriage data

```{r read NCH marriage data, warning = F}
#### marriage
ms <- fread(paste0(pathsource, "CDC-NCHS/MarriageNCHS.prn"), 
  header = T)
m8 <- lapply(list.files(paste0(pathsource, "CDC-NCHS/ocr./"), 
  pattern = "8.c.*prn", full.names = T), fread, header = T)
m8 <- lapply(m8, function(x) x[, 1:6])
m8[[2]] <- m8[[2]][, -(2:3)]
m8 <- Reduce(function(...) merge(..., all = TRUE), m8)
m1 <- Reduce(function(...) merge(..., all = TRUE), list(ms, m8))
setnames(m1, grepout("^1", colnames(m1)), 
  paste0("v.", grepout("^1", colnames(m1))))
m1L <- reshape(m1, direction = "long", idvar = "StateName", 
  varying = grepout("^v", colnames(m1)))
setkey(m1L, time)
m1LW <- reshape(m1L, direction = "wide", idvar = "time", 
  timevar = "StateName", v.names = "v")
setnames(m1LW, grepout("^v", colnames(m1LW)), 
  gsub("^v.", "", grepout("^v", colnames(m1LW))))
m1L[, m6165 := mean(v[1961 <= time & time <= 1965]), by = .(StateName)]
m1L[, vs := v-m6165]
m1L[, vs := vs/var(vs, na.rm = T)^(.5), by = .(StateName)]
m1L[, m6165 := NULL]
#### divorce data, marriage rate data follow the same steps, 
#### so omitted from markdown.
#### Tennessee: Halved in 1975? Check for NBER data integrity.
t(m1LW[1972 <= time & time <= 1978, .(time, Tennessee)])
```
This shows NBER data for Tennessee has a problem. Number of marriage did not halve in 1975.  

Display NAs in divorce data. There are some before 1959.  
```{r read NCH divorce data, echo = F, warning = F}
#### divorce
ds <- fread(paste0(pathsource, "CDC-NCHS/divorce.prn"), 
  header = T)
d8 <- lapply(list.files(paste0(pathsource, "CDC-NCHS/ocr./"), 
  pattern = "div.*prn", full.names = T), fread, header = T)
d8 <- lapply(d8, function(x) x[, 1:7])
d8[[2]] <- d8[[2]][, -c(2:3, 7)]
d8[[3]] <- d8[[3]][, -7]
d8 <- Reduce(function(...) merge(..., all = TRUE), d8)
d1 <- Reduce(function(...) merge(..., all = TRUE), list(ds, d8))
setnames(d1, grepout("^1", colnames(d1)), 
  paste0("v.", grepout("^1", colnames(d1))))
d1L <- reshape(d1, direction = "long", idvar = "StateName", 
  varying = grepout("^v", colnames(d1)))
d1L[, v := as.numeric(v)]
#### using Dunn v Palermo (1974) as reference year
####d1L[, vs := v-v[time==1974], by = .(StateName)]
#### using 1961-1965 as reference period
d1L[, m6165 := mean(v[1961 <= time & time <= 1965]), by = .(StateName)]
d1L[, vs := v-m6165]
d1L[, vs := vs/var(vs, na.rm = T)^(.5), by = .(StateName)]
d1L[, m6165 := NULL]
setkey(d1L, time)
d1LW <- reshape(d1L, direction = "wide", idvar = "time", 
  timevar = "StateName", v.names = grepout("^v", colnames(d1L)))
####setnames(d1LW, grepout("^v", colnames(d1LW)), 
####  gsub("^v.", "", grepout("^v", colnames(d1LW))))
#### Discard years before last NA in v, save it as d2L
d1L[, LastNAYear := max(time[is.na(v)]), by = StateName]
d1L[time == LastNAYear, ][order(StateName, time)]
d2L <- d1L[time > LastNAYear, ]
d1L[, LastNAYear := NULL]
d2L[, LastNAYear := NULL]
qsave(m1LW, paste0(pathsave, "marriage.qs"))
qsave(m1L, paste0(pathsave, "m1L.qs"))
qsave(d1LW, paste0(pathsave, "divorce.qs"))
qsave(d1L, paste0(pathsave, "d1L.qs"))
qsave(d2L, paste0(pathsave, "d2L.qs"))
```
```{r read NCH rate data, warning = F, echo = F}
#### marriage rate
ms <- fread(paste0(pathsource, "CDC-NCHS/MarriageRate.prn"), 
  header = T)
ms <- data.table(ms[, 1], sapply(ms[, -1], function(x) x/10))
m8 <- lapply(list.files(paste0(pathsource, "CDC-NCHS/ocr./"), 
  pattern = "8.c.*prn", full.names = T), fread, header = T)
m8 <- lapply(m8, function(x) x[, c(1, 7:11), ])
m8[[2]] <- m8[[2]][, -(2:3)]
m8 <- Reduce(function(...) merge(..., all = TRUE), m8)
m2 <- Reduce(function(...) merge(..., all = TRUE), list(ms, m8))
setnames(m2, grepout("^1", colnames(m2)), 
  paste0("v.", grepout("^1", colnames(m2))))
m2L <- reshape(m2, direction = "long", idvar = "StateName", 
  varying = grepout("^v", colnames(m2)))
options(warn = 0)
m2L[, v := as.numeric(v)]
m2L[, vs := v/var(v)^(.5), by = .(StateName)]
#### using Dunn v Palermo (1974) as reference year
m2L[, vs := vs-vs[time==1974], by = .(StateName)]
#### using 1961-1965 as reference period
m2L[, m6165 := mean(v[1961 <= time & time <= 1965]), by = .(StateName)]
m2L[, vs := v-m6165]
m2L[, vs := vs/var(vs)^(.5), by = .(StateName)]
m2L[, m6165 := NULL]
setkey(m2L, time)
m2LW <- reshape(m2L, direction = "wide", idvar = "time", 
  timevar = "StateName", v.names = grepout("^v", colnames(m2L)))
setnames(m2LW, grepout("^v", colnames(m2LW)), 
  gsub("^v.", "", grepout("^v", colnames(m2LW))))
qsave(m2LW, paste0(pathsave, "marriagerate.qs"))
qsave(m2L, paste0(pathsave, "m2L.qs"))
```
```{r implied pop divorce rate}
#### implied population
library(qs)
m1L <- qread(paste0(pathsave, "m1L.qs"))
m2L <- qread(paste0(pathsave, "m2L.qs"))
m12L <- merge(m2L, m1L, by = c("StateName", "time"), all = T)
m12L[, pop := round(v.y/(v.x/100), 0)]
m12L <- m12L[, .(StateName, time, pop)]
#### compute divorce rate
d2L <- qread(paste0(pathsave, "d2L.qs"))
d2L[, v := as.numeric(v)]
d12L <- merge(d2L, m12L, by = c("StateName", "time"))
setnames(d12L, "v", "case")
d12L[, v := round((case/pop)*100, 1)]
d12L[, m6165 := mean(v[1961 <= time & time <= 1965]), by = .(StateName)]
d12L[, vs := v-m6165]
d12L[, vs := vs/var(vs)^(.5), by = .(StateName)]
d12L[, m6165 := NULL]
qsave(d12L, paste0(pathsave, "d12L.qs"))
```

```{r Tennessee Dunn v Palermo 1975 plot 2, echo = F, fig.cap = "Number of marriages: Tennessee and contiguous states before and after Dunn v. Palermo", fig.fullwidth = F, warning = F}
m1L <- qread(paste0(pathsave, "m1L.qs"))
g <- ggplot(data = m1L[grepl("Ten|Ken|Missi|Ark|Alab|Geor|^V.*a$|Nor.*C", StateName), ], 
  aes(x = time, y = v, group = StateName, 
    shape = StateName, colour = StateName)) + 
  geom_point() +
  geom_line() +
  scale_y_log10() +
  scale_shape_manual(values = 0:10) +
  geom_vline(xintercept = 1975, colour = "red") + 
  scale_color_manual(values = c(
    "Alabama" = "lightblue", "Arkansas" = "lightblue", 
    "Georgia" = "lightblue", "Kentucky" = "lightblue", 
    "Mississippi" = "lightblue", "North Carolina" = "lightblue", 
    "Virginia" = "lightblue", "Tennessee" = "darkblue")) + ThisTheme +
  guides(colour=guide_legend(ncol=2, byrow=F))
pdf(file =  
  paste0(pathsavefigure, "TennesseeMarriageLevels.pdf"),
  , width = 2*8/2.54, height = 2*5/2.54, pointsize = 10) # native unit: inch
print(g)
whatever <- dev.off()
```
```{r Tennessee Dunn v Palermo 1975 plot standardized 1974 as zero, echo = F, fig.cap = "Number of marriages (standardized, 1974 = 0): Tennessee and contiguous states before and after Dunn v. Palermo", fig.fullwidth = F}
m1L <- qread(paste0(pathsave, "m1L.qs"))
#### 1974 as the reference period
m1L[, vs := v-v[time==1974], by = .(StateName)]
m1L[, vs := vs/var(vs)^(.5), by = .(StateName)]
g <- ggplot(data = m1L[grepl("Ten|Ken|Missi|Ark|Alab|Geor|^V.*a$|^Nor.*C", StateName)
   & 1960 <= time & time <= 1987 , ], 
  aes(x = time, y = vs, group = StateName, 
    shape = StateName, colour = StateName)) + 
  geom_point() +
  geom_line() +
  scale_shape_manual(values = 0:10) +
  geom_vline(xintercept = 1975, colour = "red") + 
  scale_color_manual(values = c(
    "Alabama" = "lightblue", "Arkansas" = "lightblue", 
    "Georgia" = "lightblue", "Kentucky" = "lightblue", 
    "Mississippi" = "lightblue", "North Carolina" = "lightblue", 
    "Virginia" = "lightblue", "Tennessee" = "darkblue")) + ThisTheme +
  guides(colour=guide_legend(ncol=2, byrow=F))
pdf(file =  
  paste0(pathsavefigure, "TennesseeMarriageStandardisedLevels1974AsZero.pdf"),
  , width = 2*8/2.54, height = 2*5/2.54, pointsize = 10) # native unit: inch
print(g)
whatever <- dev.off()
```
```{r Tennessee Dunn v Palermo 1975 plot standardized, echo = F, fig.cap = "Number of marriages (standardized, mean of 1961-65 as zero): Tennessee and contiguous states before and after Dunn v. Palermo", fig.fullwidth = F}
m1L <- qread(paste0(pathsave, "m1L.qs"))
g <- ggplot(data = m1L[grepl("Ten|Ken|Missi|Ark|Alab|Geor|^V.*a$|^Nor.*C", StateName)
   & 1960 <= time & time <= 1987 , ], 
  aes(x = time, y = vs, group = StateName, 
    shape = StateName, colour = StateName)) + 
  geom_point() +
  geom_line() +
  scale_shape_manual(values = 0:10) +
  geom_vline(xintercept = 1975, colour = "red") + 
  scale_color_manual(values = c(
    "Alabama" = "lightblue", "Arkansas" = "lightblue", 
    "Georgia" = "lightblue", "Kentucky" = "lightblue", 
    "Mississippi" = "lightblue", "North Carolina" = "lightblue", 
    "Virginia" = "lightblue", "Tennessee" = "darkblue")) + ThisTheme +
  guides(colour=guide_legend(ncol=2, byrow=F))
pdf(file =  
  paste0(pathsavefigure, "TennesseeMarriageStandardisedLevels.pdf"),
  , width = 2*8/2.54, height = 2*5/2.54, pointsize = 10) # native unit: inch
print(g)
whatever <- dev.off()
```
```{r Tennessee Dunn v Palermo 1975 plot rate standardized 1974 as zero, echo = F, fig.cap = "Marriage rates (standardized, 1974=0): Tennessee and contiguous states before and after Dunn v. Palermo", fig.fullwidth = F}
#### 1974 as the reference period
m2L <- qread(paste0(pathsave, "m2L.qs"))
m2l <- m2L[grepl("Ten|Ken|Missi|Ark|Alab|Geor|^V.*a$|^Nor.*C", StateName)
   & 1960 <= time & time <= 1987 , ]
m2l[, vs := v-v[time==1974], by = .(StateName)]
m2l[, vs := vs/var(vs)^(.5), by = .(StateName)]
g <- ggplot(data = m2l, 
  aes(x = time, y = vs, group = StateName, 
    shape = StateName, colour = StateName)) + 
  geom_point(size = 2) +
  geom_line() +
  scale_shape_manual(values = 0:10) +
  geom_vline(xintercept = 1975, colour = "red") + 
  scale_color_manual(values = c(
    "Alabama" = "lightblue", "Arkansas" = "lightblue", 
    "Georgia" = "lightblue", "Kentucky" = "lightblue", 
    "Mississippi" = "lightblue", "North Carolina" = "lightblue", 
    "Virginia" = "lightblue", "Tennessee" = "darkblue")) + ThisTheme +
  guides(colour=guide_legend(ncol=2, byrow=F))
pdf(file =  
  paste0(pathsavefigure, "TennesseeMarriageStandardisedRates1974AsZero.pdf"),
  , width = 2*8/2.54, height = 2*5/2.54, pointsize = 10) # native unit: inch
print(g)
whatever <- dev.off()
```
```{r Tennessee Dunn v Palermo 1975 plot rate standardized, echo = F, fig.cap = "Marriage rates (standardized, mean of 1961-65 as 0): Tennessee and contiguous states before and after Dunn v. Palermo", fig.fullwidth = F}
#### 1961-1965 as the reference period
m2L <- qread(paste0(pathsave, "m2L.qs"))
m2l <- m2L[grepl("Ten|Ken|Missi|Ark|Alab|Geor|^V.*a$|^Nor.*C", StateName)
   & 1960 <= time & time <= 1987 , ]
g <- ggplot(data = m2l, 
  aes(x = time, y = vs, group = StateName, 
    shape = StateName, colour = StateName)) + 
  geom_point(size = 2) +
  geom_line() +
  scale_shape_manual(values = 0:10) +
  geom_vline(xintercept = 1975, colour = "red") + 
  scale_color_manual(values = c(
    "Alabama" = "lightblue", "Arkansas" = "lightblue", 
    "Georgia" = "lightblue", "Kentucky" = "lightblue", 
    "Mississippi" = "lightblue", "North Carolina" = "lightblue", 
    "Virginia" = "lightblue", "Tennessee" = "darkblue")) + ThisTheme +
  guides(colour=guide_legend(ncol=2, byrow=F))
pdf(file =  
  paste0(pathsavefigure, "TennesseeMarriageStandardisedRates.pdf"),
  , width = 2*8/2.54, height = 2*5/2.54, pointsize = 10) # native unit: inch
print(g)
whatever <- dev.off()
```

```{r plot horizontally aligned Tennessee, eval = F, echo = F, fig.show = "hold", fig.fullwidth = F, out.width = "49%"}
#### 1961-1965 as the reference period
ggplot(data = m2l, 
  aes(x = time, y = vs, group = StateName, 
    shape = StateName, colour = StateName)) + 
  geom_point(size = 2) +
  geom_line() +
  scale_shape_manual(values = 0:10) +
  geom_vline(xintercept = 1975, colour = "red") + 
  scale_color_manual(values = c(
    "Alabama" = "lightblue", "Arkansas" = "lightblue", 
    "Georgia" = "lightblue", "Kentucky" = "lightblue", 
    "Mississippi" = "lightblue", "North Carolina" = "lightblue", 
    "Virginia" = "lightblue", "Tennessee" = "darkblue")) + ThisTheme +
  guides(colour=guide_legend(ncol=2, byrow=F))
ggplot(data = m1L[grepl("Ten|Ken|Missi|Ark|Alab|Geor|^V.*a$|^Nor.*C", StateName)
   & 1960 <= time & time <= 1987 , ], 
  aes(x = time, y = vs, group = StateName, 
    shape = StateName, colour = StateName)) + 
  geom_point() +
  geom_line() +
  scale_shape_manual(values = 0:10) +
  geom_vline(xintercept = 1975, colour = "red") + 
  scale_color_manual(values = c(
    "Alabama" = "lightblue", "Arkansas" = "lightblue", 
    "Georgia" = "lightblue", "Kentucky" = "lightblue", 
    "Mississippi" = "lightblue", "North Carolina" = "lightblue", 
    "Virginia" = "lightblue", "Tennessee" = "darkblue")) + ThisTheme +
  guides(colour=guide_legend(ncol=2, byrow=F))

```

```{r plot pdf horizontally aligned Tennessee, eval = F, echo = F, fig.show = "hold", fig.fullwidth = F, out.height = "450px", out.width = "525px"}
knitr::include_graphics(paste0(pathsavefigure, 
  c(
    "TennesseeMarriageStandardisedRates.pdf", 
    "TennesseeMarriageStandardisedLevels.pdf"
    #,
    #"TennesseeMarriageLevels.pdf"
    )), dpi = NA)
```
Event-study plots of standardised marriage rates (left) and standardised marriages (right) in Tennessee and contiguous states. Standardisation takes mean of 1961-65 as its mean (top row) and set 1974 as zero (bottom row). Rate = marriages / 1000, where population is based on censuses (April 1 of 1960, 70, 80) and interpolated estimates of July 1 of each year. 

```{r plot 1974AsZero pdf horizontally aligned Tennessee for pdf, eval = T, echo = F, fig.show = "hold", fig.fullwidth = F, out.height = "500mm", out.width = "575mm"}
knitr::include_graphics(paste0(pathsavefigure, 
  c(
    "TennesseeMarriageStandardisedRates1974AsZero.pdf", 
    "TennesseeMarriageStandardisedLevels1974AsZero.pdf"
    #,
    #"TennesseeMarriageLevels.pdf"
    )), dpi = NA)
```
```{r raw plot pdf horizontally aligned Tennessee for pdf, eval = T, echo = F, fig.show = "hold", fig.fullwidth = F, out.height = "500mm", out.width = "575mm"}
knitr::include_graphics(paste0(pathsavefigure, 
  c(
    "TennesseeMarriageStandardisedRates.pdf", 
    "TennesseeMarriageStandardisedLevels.pdf"
    #,
    #"TennesseeMarriageLevels.pdf"
    )), dpi = NA)
```

These plots indicate that Tennessee before Dunn v. Palermo had low marriage numbers in levels and in rates, and they elevated to one of the top in the group of states in 1972-1981. We cannot see any obvious impacts of Dunn v. Palermo from the plots.

```{r plot divorce Tennessee, eval = T, echo = F, warning = F, fig.cap = "Divorce rates (standardized, mean = 1961-65): Tennessee and contiguous states before and after Dunn v. Palermo", fig.show = "hold", fig.fullwidth = F, out.width = "100%"}
d12L <- qread(paste0(pathsave, "d12L.qs"))
ggplot(data = d12L[grepl("Ten|Ken|Missi|Ark|Alab|Geor|^V.*a$|^Nor.*C", StateName)
   & 1960 <= time & time <= 1987 , ], 
  aes(x = time, y = vs, group = StateName, 
    shape = StateName, colour = StateName)) + 
  geom_point() +
  geom_line() +
  scale_shape_manual(values = 0:10) +
  geom_vline(xintercept = 1975, colour = "red") + 
  scale_color_manual(values = c(
    "Alabama" = "lightblue", "Arkansas" = "lightblue", 
    "Georgia" = "lightblue", "Kentucky" = "lightblue", 
    "Mississippi" = "lightblue", "North Carolina" = "lightblue", 
    "Virginia" = "lightblue", "Tennessee" = "darkblue")) + ThisTheme +
  guides(colour=guide_legend(ncol=2, byrow=F))

```

Divorce rates also do not seem to respond to Dunn v. Palermo for Tennessee.

By a casual observation, marriage and divorce do not seem to be affected by asserting woman's name rights.

# History of woman's name rights in the US


## An overview 

Most of the name right research starts with around 1900's, the period of no name right. Then proceeds to the 1970's when woman's name right was affirmed in various litigations.  

There are many litigations that were negative on the right before the landmark *Stuart v. Board of Directors (1972)* and *Dunn v. Palermo (1974)* which gave affirmative decisions. In negating the right, many courts counted on [*Chapman v Phoenix National Bank (1881)*](https://casetext.com/case/chapman-v-phoenix-natl-bk-of-city-of-ny). As seen in below, however, *Chapman* is now regarded as an outlier that does not resonate well with historical legal precedents.^[In [*Davis and Roos (1976)*](https://casetext.com/case/davis-v-roos#:~:text=It%20is%20our%20conclusion%20that%20history%20or%20precedent%20fails%20to%20support%20the%20%22Chapman%22%20enunciations.), the court writes: It is our conclusion that history or precedent fails to support the "Chapman" enunciations.] This follows from the research on common law in even earlier years of England.

In [*Davis v. Roos (1976)*](https://casetext.com/case/davis-v-roos#:~:text=the%20common%20law%20of%20England%20on%20July%204%2C%201776%2C%20did%20not%20by%20operation%20of%20law%20engraft%20the%20husband%27s%20surname%20upon%20the%20wife.), the court noted the earliest case in the common law right on woman's name:  

> the common law of England on July 4, 1776, did not by operation of law engraft the husband's surname upon the wife. 

Similarly, in *Malone v. Sullivan, 124 Ariz. 469, 470 (Ariz. 1980)*, the English court in 1823 is quoted as: 

> It has been asserted in the argument, that a married woman cannot legally bear any other name than that which she has acquired in wedlock; but the fact is not so; a married woman may legally bear a different name from her husband, and very many living instances might be quoted in proof of the fact. [The King v. The Inhabitants of St. Faith's Newton, 3 Dowling Ryland Reports 348, 352.]  

[*Malone v. Sullivan (1980)*](https://casetext.com/case/malone-v-sullivan?__cf_chl_tk=QeU0PxkkDYrcwvpVuCLMyRCib6JBZ85sHh08oGix5r8-1703749664-0-gaNycGzNFRA#:~:text=It%20would%20appear%20that%20the%20custom%20of%20the%20wife%27s%20taking%20the%20name%20of%20the%20husband%20at%20the%20time%20of%20marriage%20remained%20just%20that%2C%20custom%2C%20and%20never%20became%20law.%20It%20was%20and%20is%20a%20question%20of%20choice%20and%20reputation.)

> It would appear that the custom of the wife's taking the name of the husband at the time of marriage remained just that, custom, and never became law. It was and is a question of choice and reputation.  
> We do not believe that *Chapman* is persuasive.  

Another good historical summary is given by [*Opinion No. 75-281 (1975)*, AG (Ops.Okla.Atty.Gen. Nov. 14, 1975)](https://casetext.com/case/opinion-no-25001?sort=relevance&resultsNav=false&q=#:~:text=(Okl.%201971).-,A%20few%20courts,-have%20enunciated%20a). The oldest case being quoted in this opinion dates back to 1897: "Also, in *Rice v. State (1897)*^[37 Tex. Cr. R. 36, 38 S.W. 801 (1897)], the Court quoted the following language with approval."  

> It is said, the husband being the head of a family, the wife and children adopt his family name, --- by custom, the wife is called by the husband's name; but whether marriage shall work any change of name at all is, after all, a mere question of choice, and either may take the other's name, or they may join their names together.   

The most important phrase in this quote is "either may take the other's name" part that indicates bloom and bride may take their own or other's name. It acknowledges the woman's name right to use her maiden name. The last part, "or they may join their names together", refers to double barrell, including the hyphenated name, to be used. Although affirmative to woman's name right, it is not evident if it also affirms a couple to use different surnames.   

The opinion goes on: "In *State v. Green (1961)*^[114 Ohio App. 497, 177 N.E.2d 616 (1961)], the Court, in determining the validity of candidacy for office of a married woman who sought to have her maiden name listed on the ballot, examined the English common law, stating:" 

> It is only by custom, in English speaking countries, that a woman, upon marriage, adopts the surname of her husband in place of her father. . . . In England, from which came our customs with respect to names, a woman is permitted to retain her maiden surname upon marriage if she so desires. 

> M. Turner-Samuels, in his book on 'The Law of Married Women' at page 345 [@TurnerSamuels1957, p.345], states: "In England, custom has long since ordained that a married woman takes her husband's name. This practice is not invariable; not compellable by law. *A wife may continue to use her maiden, married, or any other name she wishes to be known by.*"  

@Lamber1973[p.781] notes on the practice in the England:  

> Men sometimes adopted their wives' surnames, and it was common for children of prominent or wealthy women to adopt their mother's surname.  


## No name right (-1960)

@Spencer1973[p.677] writes that courts have consistently held that a woman automatically assumes husband's surname by operation of law, not merely as a matter of custom. For starters, Spencer (1973, p.667) cites NY Court of Appeals [*Chapman v Phoenix National Bank No.85 NY (1881)*](https://casetext.com/case/chapman-v-phoenix-natl-bk-of-city-of-ny) as the first important American case of not allowing woman's name rights:  

> . . . a woman, upon marriage, takes her husband's surname. That becomes her legal name, and _she ceases to be known by her maiden name. ...(snip)... Her maiden name is absolutely lost, and she ceases to be known thereby._  

In [*People* ex rel. *Rago v Lipsky (1941)*](https://casetext.com/case/people-ex-rel-rago-v-lipsky), the court sites *Freeman and Chapman ()* that declares (Spencer 1973, p.671)  

> . . . it is well settled by common-law principles and immemorial custom that _a woman upon marriage abandons her maiden name and takes her husband's surname._^[This is not an exact quote: [Under common law principles and immemorial custom, upon marriage, woman abandons her maiden name and takes husband's surname, with which is used her own given name.](https://casetext.com/case/people-ex-rel-rago-v-lipsky#:~:text=Under%20common%20law%20principles%20and%20immemorial%20custom%2C%20upon%20marriage%2C%20woman%20abandons%20her%20maiden%20name%20and%20takes%20husband%27s%20surname%2C%20with%20which%20is%20used%20her%20own%20given%20name.)]  

However, the relationship between the law and the custom, where traditionally the law demands a woman to change the surname and is also accepted as a custom, began to switch in some courts. In Ohio, State ex rel. *Bucher v Brower (1941)* and [*State, ex rel. Krupa v. Green (1961)*](https://casetext.com/case/state-ex-rel-krupa-v-green), court holds that a woman takes her husband's surname as a matter of custom, rather than automatic operation of law. 


In *Forbush v. Wallace (Sep 28, 1971)*, Alabama District Court [concludes](https://casetext.com/case/forbush-v-wallace#:~:text=this%20Court%20that-,plaintiff%27s%20motion,-for%20a%20preliminary) that it is not a constitutional right for a woman to use her maiden name in the driver's license ^[. . . "plaintiff's motion" (that the Alabama Department of Public Safety's regulation that requires a married woman to use her husband's surname in obtaining a driver's license in violation of the Fourteenth Amendment to the United States Constitution) " ... is hereby denied."], but it no longer refers it as an operation of law. 


## After 1971

After *Forbush v. Wallace (Sep 28, 1971)*, the courts started to lean towards affirmative to woman's name right by referencing the common law stating anyone can chooses own name without a legal proceeding. This is under the pretext that the common law regarded the Christian name, with the sanction of baptism behind it, as all important [(Rice v. Department of Health \& Rehabilitative Services, 386 So. 2d 844 (Fla. Dist. Ct. App. 1980)).](https://casetext.com/case/rice-v-dhrs#:~:text=The%20common%20law%20regarded%20the%20Christian%20name%2C%20with%20the%20sanction%20of%20baptism%20behind%20it%2C%20as%20all%20important.)  

Legal experts started to question the restrictions imposed by statutes despite the common law name rights, as in @BysiewiczMacDonnell1972[p.603]:  

> The absence of name change requirement at the time of marriage should invalidate any other effort to compel adoption of the husband's surname. _If the state wishes the two parties to take husband's surname at marriage, it can so provide; the only one that has done so is Hawaii._^[Hawaii [&sect; 574-a](https://www.capitol.hawaii.gov/slh/Years/SLH1975/SLH1975_Act114.pdf): Every married woman shall adopt her husband's surname as a family name.]




As stated in [*Matter of Halligan (1974)*](https://casetext.com/case/matter-of-halligan-3#:~:text=Under%20the%20common%20law%20a%20person%20may%20change%20his%20or%20her%20name%20at%20will%20so%20long%20as%20there%20is%20no%20fraud%2C%20misrepresentation%20or%20interference%20with%20the%20rights%20of%20others%20(%20Smith%20v.%20United%20States%20Cas.%20Co.%2C%20197%20N.Y.%20420%2C%20428%2D429%3B%20Matter%20of%20Wing%2C%204%20Misc.2d%20840).), 

> Under the common law a person may change his or her name at will so long as there is no fraud, misrepresentation or interference with the rights of others (Smith v. United States Cas. Co., 197 N.Y. 420, 428-429; Matter of Wing, 4 Misc.2d 840). ... _Under common law the change is accomplished by usage or habit._   



Spencer (1973) notes that a challenge by woman's name right arises from incidental and accidental category where convenience of administrative procedure, such as court notification using husband's surname, is at issue, and the direct attack on marital surname rule category where the legal surname of woman is at issue, such as voter registration under the woman's maiden name. 

The opinion also notes the divide in the legal decisions^["A few courts have enunciated a common law rule that a woman, upon her marriage, takes her husband's surname by operation of law [Chapman v. Phoenix National Bank, 85 N.Y. 437 (1881); People ex rel. Rago v. Lipsky, 327 Ill. App. 63, 63 N.E.2d 462 (1945), Forbush v. Wallace, 341 F. Supp. 217 (N.D. Ala. 1971)]. However, the most comprehensive examination of the common law rule regarding a woman's surname upon marriage is *Stuart v. Board of Supervisors of Elections (1972)* [266 Md. 440, 295 A.2d 223, 225 (1972)], wherein the Court stated: 'What constitutes the correct legal name of a married woman under common law principles is a question which has occasioned a sharp split of authorities...' "].


The opinion on the trends in 1970's notes that the *Stuart* case in 1972 marks the turnaround. It writes: "Of the recent decisions regarding a married woman's surname, the *Stuart* case is the better reasoned one. In it, the Court:"  

> . . . Recognized the common law right of any person, absent a statute to the contrary, . . . if a married woman could lawfully adopt an assumed name without legal proceedings, the Maryland law manifestly permitted *a married woman to retain her birth given name* by the same procedure of consistent, nonfraudulent use following her marriage.  

Stuart's court also notes that the law does not automatically establish majority choice of using husband's surname as a law^[That a married woman's surname does not become that of her husband where . . . she evidences a clear intent to consistently and nonfraudulently use her birth given name subsequent to her marriage. Thus . . . the mere fact of the marriage does not, as a matter of law, operate to establish the custom and tradition of the majority as a rule of law binding upon all. (p. 227)].  

Finally, the opinion decides on the Oklahoma case:^["With regard to voluntary name change, prior to the effective date of the Change of Name Act, supra, Oklahoma followed the common law rule stated in Syllabus 1 by the Court in *Huff v. State Election Board (1934)* [168 Okl. 277, 32 P.2d 920, 93 A.L.R. 906 (1934)]. A person may, at common law, change his or her name in good faith and for an honest purpose, by adopting a new name and transacting his or her business and holding himself or herself out under the new name, with the acquiescence and recognition of his or her friends and acquaintances, and this right is not abrogated by the Constitution or any statute of this state. The name that a woman assumes by marriage not being governed by statutory provisions, and the allowance by the exclusionary section of the Change of Name Act (viz., 1637, supra) of a change of name by marriage without formal court proceedings, permit a married woman to retain her maiden surname, or to assume her husband's surname and retain all or as much of her maiden name as she chooses."]  

> The name that a woman assumes by marriage not being governed by statutory provisions, and the allowance by the exclusionary section of the Change of Name Act (viz., 1637, supra) of a change of name by marriage without formal court proceedings, permit a married woman to retain her maiden surname, or to assume her husband's surname and retain all or as much of her maiden name as she chooses.  



Opinions of judges are found in https://law.justia.com/ or https://casetext.com/case/. Another great resource is https://commonlaw.name/ where legal cases of name changes are collected for each state. 


# Creating event date file

```{r read law files}
LFlist <- lapply(list(
  paste0(pathsave, "Augustine1997Footnote18.tex")
  , paste0(pathsave, "MacDougallFootnote9.prn")
  , paste0(pathsave, "FirstYearAppearingInMacDougallFootnote9.prn")
  ), fread)
names(LFlist) <- c("Augustine", "MacDougall", "MacDougallYear")
setnames(LFlist[[2]], "reference", "ref")
```

@MacDougall1985[footnote9] and @Augustine1997[footnote18] list the legal cases in each state that women's name right was acknowledged for the first time in the judicial system. 

```{css toggle, echo = F}
.toggle {
  height: 2.0em;
  overflow-y: hidden;
}
.toggle.open {
  height: auto;
}
```

```{r list MacDougall1985}
sy <- merge(LFlist[[1]][, .(state, year, case, ref)], LFlist[[2]][, 
  .(state, year, case, ref)], 
  by = c("state", "case"), all = T, suffixes = c(".A", ".M"))
setkey(sy, state, year.A, year.M)
```
<div class="toggle"><button type="button" class="btn btn-default">Show code</button>
</div>



In below, I add exerpts from various legal documents. <details><summary>Click here to see code</summary>
```{r add to MacDougall1985}
sy[grepl("Alab", state), ref.M := paste(ref.M, "[[Seiro added:](https://casetext.com/case/state-v-taylor-832#:~:text=and%20general%20relief.-,The%20trial%20judge,-held%20a%20hearing)  a married woman's right to register to vote in her maiden name. ...(snip)... The Board of Registrars filed an answer ...(snip)... the legal name of a married woman is her husband's surname. ...(snip)... The trial judge held a hearing ...(snip)... The order directed the board to register Taylor and Theriot in their maiden surnames. ...(snip)... The judgment of the trial court is due to be affirmed.]")]
sy[grepl("Ari", state) & grepl("Laks", case), ref.M := paste(ref.M, "[[Seiro added:](https://casetext.com/case/laks-v-laks#:~:text=of%20the%20children%3F%22-,Appellant,-%2C%20in%20a%20memorandum)  Appellant ... had, without appellee's consent, changed the surname of the three minor children ... to that of 'Eliot-Laks', Eliot being her maiden name. ...(snip)...  the trial court found it was not in the best interest of the children to effectuate the name change. Primrock v. Wilson, 55 Ariz. 192, 100 P.2d 180 (1940). Affirmed.]")]
sy[grepl("Ari", state) & grepl("Mal", case), ref.M := paste(ref.M, "[[Seiro added:](https://casetext.com/case/malone-v-sullivan#:~:text=Respondent%27s%20refusal%20to%20grant%20petitioner%27s%20petition%20solely%20because%20it%20was%20filed%20under%20her%20maiden%20surname%20was%20error.) Did the commissioner abuse his discretion in refusing to consider petitioner's petition for dissolution of marriage because the petition was filed in petitioner's maiden or paternal surname rather than in her husband's surname? ...(snip)... Respondent's refusal to grant petitioner's petition solely because it was filed under her maiden surname was error.]")]
sy[grepl("Ark", state) & grepl("Apr", ref.M), ref.M := 
  paste(ref.M, "[[Seiro added:](https://law.justia.com/cases/federal/district-courts/FSupp/391/1395/1494569/#:~:text=an%20opinion%20from%20the%20Attorney%20General%20of%20Arkansas%2C%20rendered%20in%20April%2C%201974%2C%20to%20the%20effect%20that%20%22there%20is%20no%20Arkansas%20law%20which%20automatically%20changes%20a%20woman%27s%20name%20to%20that%20of%20her%20husband%20upon%20marriage.%22) an opinion from the Attorney General of Arkansas, rendered in April, 1974, to the effect that 'there is no Arkansas law which automatically changes a woman's name to that of her husband upon marriage.']")]
sy[grepl("Ark", state) & grepl("Pamela", ref.M), ref.M := 
  paste(ref.M, "[[Seiro added:](https://law.justia.com/cases/federal/district-courts/FSupp/391/1395/1494569/#:~:text=Under%20Arkansas%20law%20a%20married%20woman%20may%20retain%20her%20maiden%20name%2C%20and%20if%20Pamela%20Walker%20did%20not%20change%20her%20name%20when%20she%20married%20she%20was%20entitled%20to%20be%20registered%20under%20her%20maiden%20name.)]")]
sy[grepl("Ark", state) & grepl("Walk", case), ref.M := 
  paste(ref.M, "[[Seiro added:](https://law.justia.com/cases/federal/district-courts/FSupp/391/1395/1494569/) Amendment 51 to the Constitution of the State of Arkansas, which amendment sets up a system of permanent registration for Arkansas voters ...(snip)... in the case of a woman her name as it appears on the affidavit must be prefixed by the word 'Miss' or 'Mrs.' so as to reflect her current or past marital status. There is no comparable requirement for male registrants. Plaintiffs claim that the section, as written and applied, is violative of the Ninth, Fourteenth and Nineteenth Amendments to the Constitution of the United States. ...(snip)... We hold, therefore, that the prefix requirement violates the Equal Protection Clause of the Fourteenth Amendment;  ...(snip)... 'The Court finds that plaintiffs are entitled under Arkansas law to use whatever name they care to use as long as the use is not for fraudulent purposes.' As has been seen, that is also the view of the Attorney General of Arkansas, and it is also the view of this full Court.]")]
sy[grepl("Cal", state), ref.M := 
  paste(ref.M, "[Seiro added: Judge noted, in a petition for a divorce, a woman has the right to use her maiden name to file the case.]")]
sy[grepl("Cal", state) & grepl("Wea", case), ref.M := 
  paste(ref.M, "[[Seiro added:](https://casetext.com/case/weathers-v-superior-court#:~:text=Accordingly%2C%20when%20a%20woman%20marries%2C%20she%20may%20choose%20to%20be%20known%20by%20the%20surname%20of%20her%20husband%20or%20by%20her%20maiden%20surname.) Accordingly, when a woman marries, she may choose to be known by the surname of her husband or by her maiden surname. ... (snip) ... The trial court thus exceeded its jurisdiction in refusing to entertain wife's petition for dissolution of marriage solely because the petition was filed in wife's maiden name.]")]
sy[grepl("Cal", state) & grepl("Wea", case), ref.A := 
  paste(ref.A, "[[Seiro added:](https://casetext.com/case/weathers-v-superior-court#:~:text=the%20issue%20of-,the%20right%20of%20a%20wife,-who%20during%20marriage)  the right of a wife who during marriage used her maiden name to petition for a dissolution of marriage in that name rather than the surname of her husband. We conclude that the wife has the right so to file her petition. ...(snip)... Accordingly, when a woman marries, she may choose to be known by the surname of her husband or by her maiden surname. ...(snip)... Although married, she may maintain an action in court using the name by which she was known prior to marriage. ([Cherrigan v. City etc. of San Francisco, 262 Cal.App.2d 643, 653, June 3, 1968](https://casetext.com/case/cherrigan-v-city-etc-of-san-francisco#p653) ])")]
sy[grepl("Conn", state) & grepl("Custer", case), ref.M := 
  paste(ref.M, "[[Seiro added:](https://casetext.com/case/custer-v-bonadies) Since the plaintiff married women established a clear legal right to register to vote under their maiden names, which they consistently use, and since no other adequate remedy exists, they are entitled to relief by mandamus.]")]
sy[grepl("Dist", state) & grepl("Brown", case), ref.M := 
  paste(ref.M, "[[Seiro added:](https://casetext.com/case/brown-v-brown-423#:~:text=The%20case%20is%20remanded%20and%20the%20trial%20court%20is%20directed%20to%20restore%20to%20appellant%20her%20maiden%20name.)] In this appeal from a judgment of divorce, appellant claims that the trial court erred in denying her request that her maiden name be restored. We agree and remand to the trial court with directions that appellant's maiden name be restored.]")]
sy[grepl("Flor", state) & grepl("Mar", case), ref.M := 
  paste(ref.M, "[[Seiro added:](https://casetext.com/case/marshall-v-state-133) Appellant, a married woman, filed a petition with the Leon County Circuit Court seeking to establish her maiden or birth name as her legal name even though she continued her marriage with her husband. There is nothing in Florida Statutes, &sect; 62.031 which prohibits a married woman from establishing her birth name as her legal name even though her marriage relationship continues.]")]
sy[grepl("Fl", state) & grepl("Dav", case), ref.M := 
  paste(ref.M, "[[Seiro added:](https://casetext.com/case/davis-v-roos#:~:text=The%20decision%20in%20Forbush) The decision in Forbush was squarely bottomed upon the court's observation that: 'Alabama has adopted the common law rule that upon marriage the wife by *operation of law* takes the husband's surname.' (Emphasis supplied.) Such may well be the common law as construed by the Alabama courts, however, after reviewing the extensive authorities on the subject, we conclude that the common law of England on July 4, 1776, did not by operation of law engraft the husband's surname upon the wife. In Florida there is not statute or judicial decision requiring a woman to take her husband's surname upon marriage. Although it is the general custom for a woman to change her name upon marriage to that of the husband, the law does not compel her to do so.]")]
sy[grepl("Flo", state) & grepl("Hoop", case), ref.M := 
  paste(ref.M, "[[Seiro added:](https://casetext.com/case/in-re-hooper-2#p403:~:text=The%20right%20of%20a%20woman) The right of a woman to her birth-given name, notwithstanding marriage, is established under Florida law. See Marshall v. State, [301 So.2d 477](https://casetext.com/case/marshall-v-state-133) (Fla. 1st DCA 1974); Davis v. Roos, [326 So.2d 226](https://casetext.com/case/davis-v-roos) (Fla. 3d DCA 1976). See also Egner v. Egner, [133 N.J. Super. 403](https://casetext.com/case/egner-v-egner-3), [337 A.2d 46](https://casetext.com/case/egner-v-egner-3) (N.J. 1975). ]")]
sy[grepl("Ge", state) & grepl("Att", case), ref.M := 
  paste(ref.M, "[[Seiro added:](https://commonlaw.name/GA-AG-Opinion-75-49.pdf) it is my official opinion that a married woman's surname is that of her husband but that she may change her name for all legal purposes, including issuance of a driver's license, by judicial decree or by consistent usage of another name without resort to judicial proceedings.]")]
sy[grepl("Ha", state) & grepl("Stat", case), ref.M := 
  paste(ref.M, "[[Seiro added:](https://law.justia.com/cases/federal/district-courts/FSupp/466/714/2360834/#:~:text=adopted%20in%201860.-,Until%201975%2C,-it%20was%20required) Until 1975, it was required that every married woman shall adopt her husband's name as a 'family name.' H.R.S. § 574-1 (1968). This was changed in 1975 to allow a wife to retain her maiden name, or a husband to take his wife's surname, or either party to choose a hyphenated combination of both surnames, in either order. L.1975, ch. 114, § 1.]")]
sy[grepl("Ill", state) & grepl("695", ref.M), ref.M := 
  paste(ref.M, "[[Seiro added:](https://ag.state.il.us/opinions/1974/S-695.pdf) It should be noted that in Illinois there is no statute which requires a woman to adopt assume, or change her own name to her husband's surname upon marriage. ]")]
sy[grepl("Ill", state) & grepl("711", ref.M), ref.M := 
  paste(ref.M, "[[Seiro added:](https://ag.state.il.us/opinions/1974/S-711.pdf) if a woman upon marriage does not assume her husband's surname but retains her maiden name, she is not required to notify the Secretary of State. ]")]
sy[grepl("Ind", state) & grepl("Hau", case), ref.M := 
  paste(ref.M, "[[Seiro added:](https://casetext.com/case/in-re-hauptly)  A woman has a common law right to do business in a name other than her married name. ...  a person may change his name at will without any legal proceedings by merely adopting another name. The mere speculation by the State that the appellant's decision to change her name might cause embarrassment to her child was not sufficient to justify the trial court's denial of the appellant's petition for a name change.]")]
sy[grepl("Io", state) & grepl("1980", ref.M), ref.M := 
  paste(ref.M, "[[Seiro added:](https://www.legis.iowa.gov/docs/publications/AGO/1043259.pdf) This is about hyphened names which the Assistant Attorney General concurs to. ]")]
sy[grepl("Jer", state) & grepl("Lawre", case), ref.M := 
  paste(ref.M, "[[Seiro added:]() Plaintiff appeals from the denial of her application for a change of name under N.J.S.A. 2A:52-1 from her married to her maiden name...(snip)... The trial judge, in an opinion published in 128 N.J. Super. 312 (Law Div. 1974), concluded: This court has great concern for the stability of the family and the marriage relationship. ...(snip)...  an abuse of the trial judge's discretion. Reversed and remanded for entry of judgment in accordance herewith. ]")]
sy[grepl("Mai", state) & grepl("Reben", case), ref.M := 
  paste(ref.M, "[[Seiro added:](https://law.justia.com/cases/maine/supreme-court/1975/342-a-2d-688-0.html) the appellant first alleges that she has a right under the common law to choose any name she wishes, unless motivated by a fraudulent purpose, and that as the Judge of Probate found no fraudulent purpose, his denial of her petition was an abuse of discretion. ... (snip) ... We sustain her appeal. ... (snip) ... This opinion, also, will leave many questions unanswered, foremost, probably, the question whether a woman takes the surname of her husband at marriage by operation of law. Traditionally this has been the almost unanimous practice in this state, yet no statute has required it and no decision of this Court has ever affirmed it as being mandated by the common law.]")]
sy[grepl("Mary", state) & grepl("Klein", case), ref.M := 
  paste(ref.M, "[[Seiro added:](https://casetext.com/case/klein-v-klein-114#:~:text=Q.%20144%20(1958).-,That%20Maryland,-follows%20the%20common) That Maryland follows the common law with respect to a name change is no longer open to question. Hardy v. Hardy, 269 Md. 412, 306 A.2d 244 (1973); Stuart v. Board of Supervisors, 266 Md. 440, 295 A.2d 223 (1972); Romans v. State, 178 Md. 588, 16 A.2d 642 (1940); Hall v. Hall, supra. ...(snip)... We hold that it is an abuse of discretion to deny a woman who requests it at the time of divorce the restoration of her prenuptial name, absent illegal, fraudulent, or immoral purposes.]")]
####sy <- rbind(sy, data.table(state = "Maryland", year.M = 1972, case = "Stuart v Board of Elections", 
####  ref.M = "266 Md. 440, 295 A.2d 223 (Md. 1972) [[This case is added by Seiro:](https://casetext.com/case/stuart-v-board-of-elections#:~:text=a%20woman%20may%20retain%20her%20birth%20name%20after%20marriage) ... a woman may retain her birth name after marriage merely by consistently and nonfraudulently using it.]"), use.names = T, fill = T)
sy[grepl("Mary", state) & grepl("Stu.*Boa", case), ref.M := 
  paste(ref.M, "[[Seiro added:](https://casetext.com/case/stuart-v-board-of-elections#:~:text=a%20woman%20may%20retain%20her%20birth%20name%20after%20marriage) a woman may retain her birth name after marriage merely by consistently and nonfraudulently using it.]")]
sy[grepl("Mass", state) & grepl("Lowe", case), ref.M := 
  paste(ref.M, "[[Seiro added:](https://law.justia.com/cases/massachusetts/supreme-court/1977/373-mass-178-2.html) In 1974 the Attorney General issued three opinions with respect to the recording and use of names. Rep. A.G., Pub. Doc. No. 12, at 105 (1974). Rep. A.G., Pub. Doc. No. 12, at 48 (1974). Rep. A.G., Pub. Doc. No. 12, at 72 (1974). Those opinions asserted and elaborated a common law principle that people may select or change their names freely if there is no fraudulent intent. The defendants, city and town clerks, refused to follow those opinions ...(snip)... We hold that the Attorney General is right and the city and town clerks are wrong, and order that the rights of the parties be declared accordingly. ...(snip)... A woman, regardless of her marital status, may change her name at will, without resorting to legal proceedings, provided it is done for an honest purpose. [187-189]]")]
sy[grepl("Michi", state) & grepl("Pio", case), ref.M := 
  paste(ref.M, "[[Seiro added:](https://casetext.com/case/piotrowski-v-piotrowski#:~:text=There%20is%20no%20requirement) There is no requirement that any person go through the courts to establish a legal change of name. ...(snip)... The circumstance that there is a minor child is not enough to support denial of the request. ...(znip)... Reversed and remanded for a decree to restore to plaintiff her maiden name. ]")]
sy[grepl("Miss", state) & grepl("Natale", case), ref.M := 
  paste(ref.M, "[[Seiro added:](https://law.justia.com/cases/missouri/court-of-appeals/1975/35880-0.html) On August 21, 1973, the court entered its order and judgment denying the Petition for Change of Name on the ground that 'Petitioner is lawfully married and resides with her legal spouse' and 'that under such circumstances the granting of said petition could be detrimental to others in the future.' The court's order did not specify who the 'others' were, but at the hearing, the court had commented, 'Where a married couple who do have and in the future are likely to have many obligations for which they are liable, I can see circumstances that would be detrimental . . .' It appears, therefore, that the trial court found that the fact of a woman's ongoing marriage is prima facie evidence of detriment to creditors sufficient to deny her petition for change of name. ...(snip)... Our research had disclosed no appellate decision in any state which affirmed the trial court's denial of a married woman's name change petition on the ground of an ongoing marriage. Petition of Hauptly, 312 N.E.2d 857 (Ind.1974); Marshall v. State, 301 So. 2d 477 (Fla.App.1974); Application of Halligan, 46 A.D.2d 170, 361 N.Y.S.2d 458 (1974); Application of Lawrence, 133 N.J.Super. 408, 337 A.2d 49 (Super.Ct.App. Div.1975). ...(snip)... The judgment is reversed and the trial court directed to issue its order changing petitioner's name as prayed. ]")]
sy[grepl("Neb", state) & grepl("Simm", case), ref.M := 
  paste(ref.M, "[[Seiro added:](https://law.justia.com/cases/nebraska/supreme-court/1978/41739-1.html) District Court denying a decree of dissolution. We reverse and remand with directions. The sole and only issue is whether the District Court erred in refusing to grant a decree of dissolution on the ground that it lacked jurisdiction because of the form of name used in the petition for dissolution. ...(snip)... At common law a married woman could legally bear a different name from her husband. The King v. The Inhabitants of St. Faith's Newton (1823), 3 Dowling & Ryland's Reports 348, Kruzel v. Podell, 67 Wis.2d 138, 226 N.W.2d 458.]")]
sy[grepl("New Hamp", state) & grepl("Mosk", case), ref.M := 
  paste(ref.M, "[[Seiro added:](https://casetext.com/case/moskowitz-v-moskowitz-12) The court affirms its prior decree wherein it found as a fact that it would not be in the best interest of the family unit to permit said change of name. The recommendation was approved by Perkins, J (of probate court, added by seiro). ...(snip)... We (NH Supreme Court, added by Seiro) do not suggest that every petition for a change of name be granted, but rather hold that some substantial reason must exist for denying such a petition. The mere fact that there are children is not sufficient ground. ...(snip)... Remanded.]")]
sy[grepl("New Yor", state) & grepl("Halli", case), ref.M := 
  paste(ref.M, "[[Seiro added:](https://casetext.com/case/matter-of-halligan-3) [Supreme Court's requirement](https://casetext.com/case/matter-of-halligan) that petitioner show 'a compelling reason' for the change, improperly imposed a burden of persuasion upon her beyond that required by the statute. ...(snip)... The order should be reversed and the petition granted.]")]
sy[grepl("N.*Car", state) & grepl("Moh", case), ref.M := 
  paste(ref.M, "[[Seiro added:](https://casetext.com/case/in-re-mohlman-1) Court of Appeals denied the petition of a married woman to use her maiden name. ..(snip)... To the extent that the court (of appeals), in denying relief and dismissing the petition, based its action upon its finding that the relief sought is unnecessary, it did so erroneously. ]")]
sy[grepl("N.?Ca", state) & grepl("Brie", case), ref.M := 
  paste(ref.M, "[[Seiro added:](https://law.justia.com/cases/federal/district-courts/FSupp/523/494/2298931/) North Carolina General Statute § 130-50(e) be, and the same is hereby adjudged and declared void and of no force or effect insofar as it precludes plaintiffs from recording the surnames of their choice on the birth certificates of their children called for under N.C.G.S. § 130-50(e). ]")]
sy[grepl("N.*Ca", state) & grepl("Brie", case), ref.M := 
  paste(ref.M, "[[Seiro added:](https://casetext.com/case/obrien-v-tilson#:~:text=3.-,North%20Carolina%20General%20Statute%20%C2%A7%20130%2D50(e),-be%2C%20and%20the)  North Carolina General Statute § 130-50(e) be, and the same is hereby adjudged and declared void and of no force or effect insofar as it precludes plaintiffs from recording the surnames of their choice on the birth certificates of their children called for under N.C.G.S. § 130-50(e).]")]
sy[grepl("Ok", state) & grepl("Op", case), ref.M := 
  paste(ref.M, "[[Seiro added:](https://casetext.com/case/sneed-v-sneed-3?__cf_chl_tk=GALYvgWoul0U8HLvqPk5QbPn60Y1sB6pkdTFKkYbyAg-1703388077-0-gaNycGzNFVA) [*Opinion No. 75-281 (1975)*, AG (Ops.Okla.Atty.Gen. Nov. 14, 1975)](https://casetext.com/case/opinion-no-25001?sort=relevance&resultsNav=false&q=#:~:text=(Okl.%201971).-,A%20few%20courts,-have%20enunciated%20a) ... permit a married woman to retain her maiden surname, or to assume her husband’s surname and retain all or as much of her maiden name as she chooses.]")]
sy[grepl("Ok", state) & grepl("Snee", case), ref.M := 
  paste(ref.M, "[[Seiro added:](https://casetext.com/case/sneed-v-sneed-3?__cf_chl_tk=GALYvgWoul0U8HLvqPk5QbPn60Y1sB6pkdTFKkYbyAg-1703388077-0-gaNycGzNFVA) the trial court refused to restore Mrs. Sneed's maiden name because she had a minor child ...(snip)... At common law a married woman was not compelled to adopt her husband's surname. ... (snip)... Reversed and remanded with directions.]")]
sy[grepl("Oh", state) & grepl("Ball", case), ref.M := 
  paste(ref.M, "[[Seiro added:](https://casetext.com/case/ball-v-brown) n Ball v. Brown, 450 F. Supp. 4, 10 (N.D.Ohio 1977), an Ohio statute requiring automatic cancellation of a woman's registration form following a change in marital status was found to violate the federal voting rights statute, 42 U.S.C. § 1971.]")]
sy[grepl("Rh", state) & grepl("Tra", case), ref.M := 
  paste(ref.M, "[[Seiro added:](https://casetext.com/case/traugott-v-petit) Woman appealed from a judgment of the Superior Court, Providence and Bristol County, Needham, J., which decreed, *inter alia*, that married women who wished to register a motor vehicle or apply for operator's license must use their Christian names followed by their husband's surnames. Appeal sustained; judgment reversed; case remanded.]")]
sy[grepl("^Vir", state) & grepl("Strik", case), ref.M := 
  paste(ref.M, "[[Seiro added:](https://casetext.com/case/in-re-strikwerda-and-antell#:~:text=should%20be%20granted.-,Since,-husband%20supports%20wife%27s) Since husband supports wife's petition, there is little likelihood that name change would have disruptive effect on the family, and it was abuse of discretion to deny petition after finding that it was not filed for illegal, fraudulent or immoral purpose. ...(snip)... Reversed and remanded.]")]
sy[grepl("^Vir", state) & grepl("Mill", case), ref.M := 
  paste(ref.M, "[[Seiro added:](https://casetext.com/case/in-re-change-of-name-of-miller#:~:text=and%20Compton%2C%20JJ.-,Married,-woman%20entitled%20to) Married woman entitled to resume maiden name under common law as applied to petitions under Code Sec. 8-577.1 (now with changes Sec. 8.01-217).]")]
sy[grepl("Was", state) & grepl("Doe", case), ref.M := 
  paste(ref.M, "[[Seiro added:](https://casetext.com/case/doe-v-dunning#:~:text=the%20court%20saw-,%22no,-legal%20impediment%20which) no legal impediment which would prevent married parents from giving the child the mother's surname.]")]
sy[grepl("Wis", state) & grepl("Kru", case), ref.M := 
  paste(ref.M, "[[Seiro added:](https://casetext.com/case/in-re-petition-of-kruzel) the issue presented was 'whether upon marriage a woman is required by law to assume the surname of her husband.' ...(snip)... Since we conclude in this case that Kathleen Rose Harney was never compelled to change her name, nor did she ever in fact adopt the surname Kruzel by usage, her petition, although ostensibly brought under sec. 296.36, Stats. 1971, amounted only to a request for judicial recognition that she had been correct in using her maiden surname in the past.]")]

#### adding cases
sy <- rbind(sy, data.table(state = "New York", year.M = 1974, case = "Matter of Halligan", 
   ref.M = "266 Md. 440, 295 A.2d 223 (Md. 1972) [[This case is added by Seiro:](https://casetext.com/case/matter-of-halligan-3/#:~:text=No%20reasonable%20objection%20appearing%2C%20appellant%20is%20entitled%20to%20her%20requested%20order%20declaring%20that%20she%20shall%20be%20known%20by%20her%20maiden%20name%20of%20Ryan%2C%20and%20no%20other.) Supreme Court's requirement that petitioner show 'a compelling reason' for the change, improperly imposed a burden of persuasion upon her beyond that required by the statute...No reasonable objection appearing, appellant is entitled to her requested order declaring that she shall be known by her maiden name of Ryan, and no other.]"), use.names = T, fill = T)
sy <- rbind(sy, data.table(state = "South Dakota", year.M = 1975, case = "Ogle v. Cir. Ct., Tenth (Now 6th) Jud. Cir",
  ref.M = "227 N.W.2d 621 (S.D. 1975) [[Seiro added:](https://casetext.com/case/ogle-v-cir-ct-tenth-now-6th-jud-cir#p21:~:text=of%20name.%20Consequently%2C-,we%20conclude,-that%20the%20trial) we conclude that the trial court abused its discretion in denying the petition without giving petitioner an opportunity to present further evidence.]"),
  use.names = T, fill = T)
sy <- rbind(sy, data.table(state = "Texas", year.M = 1974, case = "Op. Att'y Gen. H-432 (October 25, 1974) Re: Whether a woman is required to assume her husband's surname as her own",
  ref.M = " [[Seiro added, page 4:](https://www.texasattorneygeneral.gov/sites/default/files/opinion-files/opinion/1974/jh0432.pdf) under this statute a woman retained her common law right to choose at marriage either to keep her name prior to marriage or to assume her husband's surname.]"), use.names = T, fill = T)
```
</details>

```{r tabulate cases}
setkey(sy, state, year.A, year.M)
sy <- sy[state != "" & (year.M >= 1972 |year.A >= 1972), .(state, case, year.A, year.M, ref.A, ref.M)]
library(kableExtra)
# all cases
kbt <- kbl(sy, align = "lcccll", 
  caption = "States with their first years in legal decisions : MacDougall and Augustine-Adams", 
  format = "html")
kbt  <- kable_styling(kbt, fixed_thead = T, full_width = F, position = "left")
kbt <- row_spec(kbt, seq(1, nrow(sy), 2), background="lightgray")
kbt <- column_spec(kbt, column = grep("case", colnames(sy)), width = "1.2cm")
kbt <- column_spec(kbt, column = 1, width = "2cm")
kbt <- column_spec(kbt, column = grep("year.A", colnames(sy)), width = "1.0cm")
kbt <- column_spec(kbt, column = grep("year.M", colnames(sy)), width = "1.0cm")
kbt <- column_spec(kbt, column = grep("ref.A", colnames(sy)), width = "5.5cm")
column_spec(kbt, column = grep("ref.M", colnames(sy)), width = "5.5cm")
```


<details><summary>Click here to see tables by match results</summary>
```{r matches}
# matching cases
sy1 <- sy[!is.na(year.M) & !is.na(year.A), .(state, year.M, case, ref.M)]
kbt <- kbl(sy1, align = "rcll", 
  caption = "States with their first years in legal decisions : Matching in MacDougall and Augustine-Adams", 
  format = "html")
kbt  <- kable_styling(kbt, fixed_thead = T, full_width = F, position = "left")
kbt <- row_spec(kbt, seq(1, nrow(sy1), 2), background="lightgray")
kbt <- column_spec(kbt, column = 3, width = "2cm")
kbt <- column_spec(kbt, column = 1, width = "2cm")
column_spec(kbt, column = 4, width = "10cm")
# only in MacDougall
sy2 <- sy[!is.na(year.M) & is.na(year.A), .(state, year.M, case, ref.M)]
kbt <- kbl(sy2, align = "rcll", 
  caption = "States with their first years in legal decisions: Only in MacDougall", 
  format = "html")
kbt  <- kable_styling(kbt, fixed_thead = T, full_width = F, position = "left")
kbt <- row_spec(kbt, seq(1, nrow(sy2), 2), background="lightgray")
kbt <- column_spec(kbt, column = 3, width = "2cm")
kbt <- column_spec(kbt, column = 1, width = "2cm")
column_spec(kbt, column = 4, width = "10cm")
# only in Augustine
sy3 <- sy[is.na(year.M) & !is.na(year.A), .(state, year.A, case, ref.A)]
kbt <- kbl(sy3, align = "rcll", 
  caption = "States with their first years in legal decisions: Only in Augustine-Adams", 
  format = "html")
kbt  <- kable_styling(kbt, fixed_thead = T, full_width = F, position = "left")
kbt <- row_spec(kbt, seq(1, nrow(sy3), 2), background="lightgray")
kbt <- column_spec(kbt, column = 3, width = "3cm")
kbt <- column_spec(kbt, column = 1, width = "2cm")
column_spec(kbt, column = 4, width = "10cm")
```
</details>

In Arkansas case, the opinion of district attorney [indicated](https://law.justia.com/cases/federal/district-courts/FSupp/391/1395/1494569/#:~:text=According%20to%20the%20affidavit%20of%20Linda%20Scholle%20she%20first%20registered%20in%20May%2C%201973%20at%20a%20time%20when%20she%20was%20unmarried) that  


> _It appears from the materials before us that the controversy arose in the late summer or early fall of 1974 ... and immediately &#42;1399 involved the plaintiffs, Walker and Scholle, who are both lawyers._  

> _She (Scholle) married in April, 1974 and retained her  
> maiden name; since she had not changed her name she  
> did not undertake to have her registration changed to reflect  
> her marriage._  

In Californian case of *Weathers v Superior Court*, State Court of Appeals Judge notes the opinion: 

> _It raises the issue of the right of a wife who during marriage used her maiden name to petition for a dissolution of marriage in that name rather than the surname of her husband. We conclude that the wife has the right so to file her petition._

It also states such right is not implemented universally. Pleading for a divorce in 1975, the acting judge [said](https://law.justia.com/cases/california/court-of-appeal/3d/54/286.html#:~:text=On%20July%2021,names%3B%20never%20have.%22):  


> _On July 21, the petition was heard by Commissioner Russell R. Hermann sitting as a temporary judge of the court. Wife appeared in propria persona while Francisco Grippa made no appearance. Commissioner Hermann called the case as "Weathers versus Grippa." He asked wife if she had married Francisco Grippa. When wife answered that she had, the commissioner replied "All of your pleadings say 'Weathers versus Grippa.'" Informed by wife that she had at no time assumed Grippa's name, the commissioner replied, "That doesn't matter whether you have assumed it or not." Amplifying when wife responded that she had never used the Grippa name, the commissioner said, "The marriage certificate makes you Mrs. Grippa." When wife protested, "No, it doesn't," Commissioner Hermann responded, "They must have an awful novel wedding certificate in Oklahoma if it doesn't." Informed by wife that the marriage certificate simply read "Janet Lynn Weathers and Francisco Grippa," the commissioner replied, "I have never divorced people with two different names; never have."_  

In Florida Marshal v State case, one judge, although concurring the decision, worries the distruction of family and leaves an opinion piece:  

> _I think it important that we here note that we are not called upon to decide whether it is requisite that upon marriage a wife assume the surname of her husband. That issue is not before us._  

In Indiana, *In re Hauptly* case, the judge's opinion reveals that the State Attorney General attacked the plaintiff who filed to use her maidenname as:

> _"Perhaps she is claiming the woman's privilege that in an argument she does not have to use reason." (Page 6)_   

> _"It can be reasonably inferred that she believes that fact that she is the breadwinner of the family should be publicized so that all will know her husband has been emasculated and that she is the head of the family." (Page 7)_  

> _". . . indicating that perhaps Mrs. Hauply's need was not for a change of name but for a competent psychiatrist." (Pages 9 and 10)_  

> _"Namely, a sick and confused woman, unhappy and unsatisfied with her marriage, unable to determine what she wants to do with her life." (Page 10)_  

> _". . . because she was a kind of odd ball . . ." (Page 10)_  

> _"[In filing a claim for hospitalization] the computer would probably fail to function and the company refuse to pay on the grounds that it was not liable for hospitalization of a mistress under the terms of a family policy." (Page 11)_  

In Illinois case, Attorney General's opinion on early case states:  

> _I do not believe that this appellate decision should control. The other Illinois decisions and cases elsewhere establish that a woman may in fact retain her own name upon marriage with or without court proceedings. (Ill. Op. Att'y Gen., February 13, 1974)._  

Tabulate earliest year entries:
```{r earliest year, warning = F}
ey <- sy[, 
  .(yr.A = min(year.A, na.rm = T), yr.M = min(year.M, na.rm = T)), 
  by = state]
ey[, yr := min(c(yr.A, yr.M)), by = state]
ey[yr.A == Inf, yr.A := NA]
ey[yr.M == Inf, yr.M := NA]
eytable <- ey[, .(State = paste(state, collapse = ", ")), by = yr]
setkey(eytable, yr)
```

```{r eytable, full.width = F}
library(kableExtra)
kbt <- kbl(eytable, align = "cl", 
  caption = "States with their first years in legal decisions", 
  format = "html")
kbt  <- kable_styling(kbt, fixed_thead = T, full_width = F, position = "left")
kbt <- row_spec(kbt, seq(1, nrow(eytable), 2), background="lightgray")
kbt <- column_spec(kbt, column = 2, width = "12cm")
column_spec(kbt, column = 1, width = "2cm")
```

@Kohout1973 discusses the conditions up to 1973. She notes name rights of women are not universally guaranteed. Some states, like New York, may allow name changes of a married woman after filing for it, but the court has a certain degree of discretion to deny the petition. The paper also hilights the *Forbush* case in which Alabama court suggested that the procedure should be simple and inexpensive.   

A federal case in *Allen v Lovejoy*  553 F2d 522 (6th Circuit Court 1977) decided that Title VII of Civil Rights Act of 1964 was violated when an employer suspended a female worker for her refusal to sign a form with post-marriage surname. 

A common law interpretation of the matter, claimed by feminists, is the following:

* Each person has the right to use and to be known by the surname of his or her choice.  
* Then, a woman to use husband's name just by using it, and similarly, to use her maiden name just by using it.  

> _Despite the clarity of this argument, by misstating precedent  
> and overemphasizing the frequency with which the change occurs,  
> many courts and officials transformed womans's option of adopting  
> her husband's surname into a legal requirement._  
> `r quote_footer('--- Omi, 1997, p. 261')`


The *Forbush* court listed state interests that restrict women's name rights:

1. Custom^[Longevity cannot be a rationale. ]  
1. Administrative convenience^[No administrative efficiency is gained by married women to change her surname upon marriage.]  
1. Prevention of fraud^[Common law name changes do not increase frauds. ]  
1. *De minimis* injury due to existence of statutory remedies^[It is not a minimal cost to change a surname.]  
1. Preservation of family unit^[Not well understood empirically.]  

In *State v Taylor*, the court acknowledged that *Forbush*'s decision is inaccurately representing the common law of Alabama.  

@Daum1974 [pp.72-73] argues that while there is a move toward ensuring women's name rights, because there was no statute to deny or allow the women's name rights, the application of the right was inconsistent.  


# Estimation

## Identification strategy

Consider an event-study design for a unit $i$ that starts being treated at $\tau$:
\[
y_{i,t}=a_{t}+a_{i}+\sum_{s=-L}^{G}\gamma_{j}D_{i,t+s}+\bfb'\bfx_{i,t}+e_{i,t},
\]
where $D_{i,t+s}=0,1$ is an indicator function equalts to 1 if $i$ is treated in $t+s$ with $s=-L, -L+1, \cdots, -1, 0, 1, 2, \cdots, G-1, G$. Given $i$ starts getting treated at $\tau$, $D_{i,t-s}=0$ for $\tau<t-s$, $D_{i, t-a}=1$ for $\tau\geqslant t-s$. The indicator $t$ measures the calendar time, $s$ measures the event time (time-since-event). So we know that time-since-event $s$ is equal to $t-\tau$, or $s=t-\tau$ or $t=s+\tau$. $\bfx_{it}$ is a vector of exogenous covariates.  

Our data structure is the hybrid type based on the classification by @Miller2023: 

* Treatment dates vary by units.  
* There are never-treated units. 

The key identifying assumptions are:  

1. In the absence of treatments, all the units share the same time effects $a_{t}$ (conditional on unit fixed effects $a_{i}$ and covariates $\bfx_{i,t}$).  
1. Selection of treatment timing, selection of treated or never-treated (by the end of our observation period) units are as good as random, given time and unit fixed effects and covariates.  

The treatment effect parameters $\bfgamma$ need to give differneces relative to a specific benchmark. It is common that to choose the benchmark of the mean pre-treatment effect, or setting $\gamma_{-1}=0$. 

To avoid multicollinearity, we need to drop one period FE from $a_{t}$, and one unit FE from $a_{i}$. 

The number of pre-treatment periods need to balance efficiency and bias tradeoff. Longer perods provide efficiency, but it risks the inclusion of irrelevant periods, such as under marital market disruption immediately after the world war II (1946 onwards). Number of states reporting marriages (*Marriage Reporting Area*) increased from 32 (1957) to 37 (1964). Non MRA states also report data by using central files or survey estimation. In 1960, 33 MRA states, 8 states and DC hold central files of marriage records to construct data. In 1961-63, 35 MRA states `r 51-35-6` states with central files. In 1964, 37 MRA states, `r 51-37-7` states^[Why decreased?] have central files. 

46 states report number of marriages performed, 5 States and DC report the number of marriage licenses issued using central files. Texas only reports data for 10 counties.  

To avoid the bias while not throwing away too much of efficiency, we choose 1961, 14 years before the landmark *Dunn v Palermo*, with 45 states in marriage data, as the starting year. 

@Miller2023 recommends to base entire pre-period to be the reference period.


```{r read NHS data file}
m2L <- qread(paste0(pathsave, "m2L.qs"))
d12L <- qread(paste0(pathsave, "d12L.qs"))
m2L <- m2L[!grepl("Cent|Mid|Mount|Eng|east|Pac|^South$|Atl?a|Unit|^West$", StateName), ]
d12L <- d12L[!grepl("Cent|Mid|Mount|Eng|east|Pac|^South$|Atl?a|Unit|^West$", StateName), ]
destat(m2L[, .(NumberOfStates=.N, NumberOfEntries=length(v[!is.na(v)])), by = time])
```

@Miller2023 recommends to base entire pre-period to be the reference period. In the paper's accompanying code, he uses `cnsreg` of stata. This is to impose a linear restriction on the estimated parameters in OLS using minimization of the Lagrangian:
\[
\mathcal L = SSE+\lambda [\bar{\gamma}_{pre}].
\]
Stata's manual on [`cnsreg`](https://www.stata.com/manuals/rcnsreg.pdf) states that it uses a linear formula which should be similar to [@Hansen2022, 8.8](https://juergenmeinecke.github.io/EMET8014/_downloads/a02e6ab05c5e8d4cad903b9c8fd339cc/Econometrics_by_Bruce_Hansen.pdf).^[Because this code is proprietary, one cannot see what it does.] 

However, in the current case, constrained least squares is not necessary. One can impose a set of nonzero constraints on $\gamma_{s}$ for $s<0$. Setting and substituting $\bar{\gamma}_{pre}=0$ changes the estimating equation:
\begin{equation}
\bar{\gamma}_{pre}=0 \quad \Leftrightarrow \quad \gamma_{-L}=-\sum_{s=-(L-1)}^{-1}\gamma_{s},
\tag{c}\label{eqnconst}
\end{equation}
so
\[
\begin{aligned}
y_{i,t}
&=
a_{t}+a_{i}+\sum_{s=-L}^{G}\gamma_{s}D_{i,t+s}+\bfb'\bfx_{i,t}+e_{i,t},\\
&=
a_{t}+a_{i}	
-\left(\gamma_{-(L-1)}+\cdots+\gamma_{-1}\right)D_{i,t-L}+\gamma_{-(L-1)}D_{i,t-(L-1)}+\cdots+\gamma_{-1}D_{i,t-1}\\
&\hspace{1em}
+\gamma_{0}D_{i,t}+\cdots+\gamma_{G}D_{i,t+G}+\bfb'\bfx_{i,t}+e_{i,t},\\
&=
a_{t}+a_{i}+
\gamma_{-(L-1)}\left(D_{i,t-(L-1)}-D_{i,t-L}\right)+\cdots+\gamma_{-1}\left(D_{i,t-1}-D_{i,t-L}\right)\\
&\hspace{1em}
+\gamma_{0}D_{i,t}+\cdots+\gamma_{G}D_{i,t+G}
+\bfb'\bfx_{i,t}+e_{i,t},\\
&=
a_{t}+a_{i}+
\sum_{s=-(L-1)}^{-1}\gamma_{s}\left(D_{i,t+s}-D_{i,t-L}\right)+\sum_{s=0}^{G}\gamma_{s}D_{i,t+s}+\bfb'\bfx_{i,t}+e_{i,t}.
\end{aligned}
\]


## Checking data problems

<details><summary>Click here to see data problem checks.</summary>
Anomalous entries.
```{r anomalous entries}
d12L[abs(vs)> 3, ][order(StateName, time)]
m2L[abs(vs)> 3, ][order(time, StateName)]
```
Data in 1956-1958 are unreliable that they use estimates. Drop from data.

```{r}
d3L <- d12L[time >= 1959, ]
m3L <- m2L[time >= 1959, ]
d3L[, vs := v/var(v)^(.5), by = .(StateName)]
d3L[, vs := vs-mean(vs[1961 <= time & time <= 1965]), by = .(StateName)]
m3L[, vs := v/var(v)^(.5), by = .(StateName)]
m3L[, vs := vs-mean(vs[1961 <= time & time <= 1965]), by = .(StateName)]
qsave(d3L, paste0(pathsave, "d3L.qs"))
qsave(m3L, paste0(pathsave, "m3L.qs"))
```
</details>
Anomalous entries.
```{r anomalous entries in trimmed data}
d3L[abs(vs)> 3, ][order(StateName, time)]
d3L[vs < -.5, ][order(StateName, time)]
m3L[abs(vs)> 3, ][order(time, StateName)]
```
Anomalous values of below can be dropped without much costs to data availability (year before 1960).  

 * `r d3L[abs(vs)> 3 & time < 1960, StateName]` from divorce rate estimation.  
 * `r m3L[abs(vs)> 3 & time < 1960, StateName]` from marriage rate estimation.  

However, it is easiest to set the starting year as 1960.

Stationarity tests.
```{r stationarity check, warning = F}
library(tseries)
  d3L[, outcome := "divorce"]
  m3L[, outcome := "marriage"]
  dm3L <- rbind(d3L, m3L, use.names = T, fill = T)
	  if (nrow(dm3L[is.na(v), ]) > 0) 
    dm3L2 <- dm3L[!is.na(v), ] else 
    dm3L2 <- dm3L
  stt <-  dm3L2[, .(
      kpss = kpss.test(v, null = "Trend")$p.value, 
      adf = adf.test(v, alternative = "stationary", k = 5)$p.value), 
      by = .(outcome, StateName)][kpss < .1 & adf < .1, ]
  print(
    sttW <- reshape(stt, direction = "wide", idvar = "StateName",
      timevar = "outcome", v.names = grepout("k|adf", colnames(stt)))
   )
```
Drop:  

 * `r sttW[!is.na(kpss.divorce), StateName]` from divorce rate estimation.  
 * `r sttW[!is.na(kpss.marriage), StateName]` from marriage rate estimation.  

```{r}
d3L <- qread(paste0(pathsave, "d3L.qs"))
m3L <- qread(paste0(pathsave, "m3L.qs"))
dvdrop <- sttW[!is.na(kpss.divorce), StateName]
mrdrop <- sttW[!is.na(kpss.marriage), StateName]
d4L <- d3L[!(StateName %in% dvdrop), ]
m4L <- m3L[!(StateName %in% mrdrop), ]
qsave(d4L, paste0(pathsave, "d4L.qs"))
qsave(m4L, paste0(pathsave, "m4L.qs"))
```

## Marriage rates and divorce rates

```{r plot marraige, eval = T, echo = F, warning = F, fig.cap = "Marriage rates (standardized with overall std and means of 1961-1965)", fig.show = "hold", fig.fullwidth = F, out.width = "100%"}
m4L <- m4L[time >= 1960, ]
m4L[, vs := v/var(v)^(.5), by = .(StateName)]
m4L[, vs := vs-mean(vs[1961 <= time & time <= 1965]), by = .(StateName)]
ggplot(data = m4L, 
  aes(x = time, y = vs, group = StateName, 
    shape = StateName, colour = StateName)) + 
  #geom_point() +
  geom_line() +   ThisTheme +
  #scale_shape_manual(values = 0:10) +
  guides(colour=guide_legend(nrow=5, byrow=F))  +
  geom_vline(xintercept = 1975, colour = "red")
```
```{r plot divorce, eval = T, echo = F, warning = F, fig.cap = "Divorce rates (standardized with overall std and means of 1961-1965)", fig.show = "hold", fig.fullwidth = F, out.width = "100%"}
d4L <- d4L[time >= 1960, ]
d4L[, vs := v/var(v)^(.5), by = .(StateName)]
d4L[, vs := vs-mean(vs[1961 <= time & time <= 1965]), by = .(StateName)]
ggplot(data = d4L, 
  aes(x = time, y = vs, group = StateName, 
    shape = StateName, colour = StateName)) + 
  #geom_point() +
  geom_line() +   ThisTheme +
  #scale_shape_manual(values = 0:10) +
  guides(colour=guide_legend(nrow=5, byrow=F))  +
  geom_vline(xintercept = 1975, colour = "red")
```

## Event dates

```{r read event date file}
fy <- fread(paste0(pathsource, "FirstYearCompiledBySeiro.prn"))
d4L <- qread(paste0(pathsave, "d4L.qs"))
m4L <- qread(paste0(pathsave, "m4L.qs"))
setnames(fy, "state", "StateName")
fy2 <- fy[, .(StateName, year, month)]
mr <- merge(m4L, fy2, by = "StateName", all = T)
dv <- merge(d4L, fy2, by = "StateName", all = T)
```
```{r plot event timing, eval = T, echo = F, warning = F, fig.cap = "Event year distribution", fig.show = "hold", fig.fullwidth = F, out.width = "100%"}
fy <- fread(paste0(pathsource, "FirstYearCompiledBySeiro.prn"))
ab <- fread(paste0(pathsource, "USStateAbbreviation.prn"), header = T)
ab[, st2 := NULL]
fy <- merge(fy, ab, by = "state")
setnames(fy, "state", "StateName")
setkey(fy, year, StateName)
fy[, vpos := 1:.N, by = year]
fy[, vpos := vpos]
fy[, Year := format(as.IDate(as.POSIXct(paste0(year, "-01-01"), format = "%Y-%m-%d")), "%Y")]
ggplot(data = fy[!is.na(year)], 
  aes(x = Year, group = StateName)) + 
  #stat_count(fill = "white", color = "blue") +
  geom_bar(fill = "white", color = "blue")+
  scale_y_continuous(name = "number of counts", breaks = c(5, 10), minor_breaks = 1:10)+
  geom_text(aes(x = Year, y = vpos-.5, label = st), color = "blue")+
  ThisTheme + 
  theme(
    axis.text.x = element_text(size=10, angle = 45, hjust = 1, vjust = 1)
  )  
```

Transform data to reflect the normalisation restriction in \eqref{eqnconst}.

```{r create event time}
for (ob in c("mr", "dv")) {
  obj = copy(get(ob))
  obj <- obj[!is.na(year), ]
  obj[, year := as.numeric(as.character(year))]
  obj[, time := as.numeric(as.character(time))]
  obj[, trend := time - min(time)+1, by = StateName]
  obj[, trend2 := trend^(2)]
  obj[, trend3 := trend^(3)]
  #### Normalization: At t-1, zero effect
  #### year is the year of first case in each state
  obj[, start := (year == time-1)]
  obj[, et := 1:.N, by = StateName]
  obj[, et := et-et[start], by = StateName]
  obj[, ptrend := trend]
  obj[, ptrend0 := trend[et==0], by = StateName]
  obj[et >= 0, ptrend := ptrend0]
  obj[, ptrend2 := trend2]
  obj[, ptrend20 := trend2[et==0], by = StateName]
  obj[et >= 0, ptrend2 := ptrend20]
  obj[, ptrend3 := trend3]
  obj[, ptrend30 := trend3[et==0], by = StateName]
  obj[et >= 0, ptrend3 := ptrend30]
  obj[, c("ptrend0", "ptrend20", "ptrend30") := NULL]
  qsave(obj, paste0(pathsave, ob, ".qs"))
  #### Normalization: mean of trend at event time < -1 is zero
  #### For this operation, keep dummy data matrix separately as etdum.
  etdum <- makeDummyFromFactor(factor(obj[, et]), nameprefix = "et")
   #### change to easier-to-handle names
  setnames(etdum, grepout("-", colnames(etdum)), 
    gsub("-", "N", grepout("-", colnames(etdum))))
   #### Subtract t-L, L=10 period to impose \bar{gamma}_{s<0} = 0
  negtime <- grepout("N", colnames(etdum))
  etdum[, (negtime) := lapply(.SD, function(x) x-etN10), .SDcols = negtime]
  etdum[, etN10 := NULL]
  #### Forcing mannually a specific order in factor levels.
  #### lm drops the first factor level as a reference.
  #### (can also be done using library(forcats), but not necessary)
  obj[, et := factor(et, levels = c(-1, unique(et)[!(unique(et) %in% -1)]))]
  obj[, time := factor(time, 
    levels = c(1988, unique(time)[!(unique(time) %in% c(1988, 1987))], 1987))]
  obj[, StateName := factor(StateName, 
    levels = c("Hawaii", 
      unique(StateName)[!(unique(StateName) %in% c("Hawaii", "Florida"))], "Florida"))]
  assign(ob, obj)
  assign(paste0(ob, "et"), etdum)
}
```

# Estimated results

## Choice of reference normalization

### A technical note on how R's `lm` works

*Multiple factors*

In a regression with no intercept with mutilple factor variables, there is a rule in the choice of reference levels in `lm`.

* The first factor variable in the formula uses all factor levels.  
* Other factor variables in the formula drop each of the first level.  

```{r try factor dummy variables, results = "hide"}
set.seed(100)
#### 10 groups (a, .., t), 60 periods
dm1 <- factor(rep(letters[1:10], each = 60))
trend <- rep(1:60, 10)
dmf <- NULL
for (gg in 1:10) {
  dm1 <- letters[gg]
  trend <- 1:60
  dm2 <- factor(sample(1:4, 60, replace = T))
  dm3 <- factor(sample(1:4, 60, replace = T))
  dm4 <- factor(sample(1:4, 60, replace = T))
  dm5 <- factor(sample(1:4, 60, replace = T))
  dm6 <- factor(sample(1:4, 60, replace = T))
  dmf0 <- data.table(y=trend+as.numeric(dm2)*9-as.numeric(dm3)*3
    -as.numeric(dm4)*6+as.numeric(dm5)*2
    -as.numeric(dm3)*1.5+rnorm(60, 0, 10), 
    id=dm1, trend, dm2, dm3, dm4, dm5, dm6)
  dmf <- rbind(dmf, dmf0)
}
dmf[, id := factor(id)]
dm <- lapply(dmf[, -c(1, 3)], makeDummyFromFactor, 
  reference = NULL, nameprefix = "")
lapply(2:length(dm), function(i) 
  setnames(dm[[i]], paste0("d", i, colnames(dm[[i]]))))
```
```{r construct dummy data, results = "hide"}
dm <- data.table(Reduce(cbind, dm))
summary(dm)
```
```{r construct dummy data 2, echo = F}
cat(paste0("Rank is ", qr(dm)$rank, ", ", "number of columns is ", ncol(dm), 
 ",\nneed to drop one level from each ", ncol(dm)-qr(dm)$rank, 
 " variables\nin a matrix of ", sum(grepl("^dm", colnames(dmf))), 
 " dummy variables.\n"))
```
```{r construct dummy data 3}
dm[, y := dmf[, y]]
lmd0 <- lm(y ~ -1 + id + dm2 + dm3 + dm4 + dm5 + dm6, data = dmf)
DFInlm <- summary(lmd0)$df
#### Taken from stats:::print.summary.lm
if (nsingular <- DFInlm[3L] - DFInlm[1L]) 
  cat("\nCoefficients: (", 
    nsingular, " not defined because of singularities)\n")
```

*Multiple factors with interactions*

```{r add double interactions}
lmd1 <- lm(y ~ -1 + id:dm2:dm3 + dm4 + dm5 + dm6, data = dmf)
DFInlm <- summary(lmd1)$df
#### Taken from stats:::print.summary.lm
if (nsingular <- DFInlm[3L] - DFInlm[1L]) 
  cat("\nCoefficients: (", 
    nsingular, " not defined because of singularities)\n")
lmdc <- lmd1$coefficients
allco <- as.vector(unlist(
  unique(dmf[, .(int=as.character(interaction(id, dm2, dm3, sep = ":")))][order(int)])))
allco <- gsub("(.):(.):", "id\\1:dm2\\2:dm3", allco)
#### Lacking 3 in dm3
dmf[id == "h" & dm2 == 2, .(id, dm2, dm3)]
```
Singularity is caused by lack of multiple observations for a particular combination of interactions.  


Double interactions attempted by lm  

* `r names(lmdc)[names(lmdc)%in%allco]`.  

All possible double interactions  

* `r allco`.  

Dropped from formula before regression (not attempted) in care of singularity  

* `r allco[!allco %in% names(lmdc)]`.  

Dropped ex post due to singularity (despite attempted)  

* `r names(lmdc[is.na(lmdc)])` which is the same as `r allco[allco %in% names(lmdc[is.na(lmdc)])]`.  


*Multiple factors with trend and interactions*


```{r add time trend group time trend}
#### Add time trend, group wise time trend
setkey(dmf, id, trend)
for (aa in letters[1:20]) {
  gt <- paste0(aa, "t")
  dmf[, (gt) := 0L]
  dmf[grepl(aa, id), (gt) := 1:.N]
}
lmd2 <- lm(y ~ -1 + id*trend*dm2 + id*trend*dm3 + id*trend*dm4
  + id*trend*dm5 + id*trend*dm6, data = dmf)
DFInlm <- summary(lmd2)$df
if (nsingular <- DFInlm[3L] - DFInlm[1L]) 
  cat("\nCoefficients: (", 
    nsingular, " not defined because of singularities)\n")
```
In a regression with no intercept, id, trend, many factors: When id, trend, all factor variables (with 5 levels) are interacted, `lm`:

* Keeps all levels of `id`.  
* Drops the first level of all factors.^[E.g., the first level (`dm21`) of `dm2`.]   
* Drops all interaction terms using dropped factor levels.^[E.g., `id:dm21`(=`ida:dm21`, .., `idj:dm21`), `trend:dm21`, `id:dm31`, `trend:dm31`.]  
* Drops any double interaction terms using dropped factor levels.^[Anything with `id21`, `id31`, `id41`, `id51`, e.g., `idj:dm51:trend`.]  
* Drops the first level of interaction terms.^[E.g., `id:trend` is collinear with `id` and `trend` unless `ida:trend` is dropped. For Y=2,...5, `id:dmXY` is collinear with  `id` and `dmXY` unless `ida:dmXY` is dropped. For Y=2,...5, `id:trend:dmX` is collinear with  `id`, `trend` and `dmXY` unless `ida:trend:dmXY` is dropped.]   
* (And keeps all other interaction terms.)  

```{r singular regressors}
lmdc <- lmd2$coefficients
allco <- as.vector(unlist(
  unique(dmf[, .(int=as.character(interaction(id, dm2, sep = ":")))
  ][order(int)])))
allco <- gsub("(.):", "id\\1:trend:dm2", allco)
```
Double interactions involving `dm2` attempted by lm  

* `r names(lmdc)[names(lmdc)%in%allco]`.  

All possible double interactions involving `dm2`  

* `r allco`.  

Dropped from formula before regression (not attempted) in care of singularity 

* `r allco[!allco %in% names(lmdc)]`.  

Dropped ex post due to singularity (despite attempted)  (none)  

* `r names(lmdc[is.na(lmdc)])` which is the same as `r allco[allco %in% names(lmdc[is.na(lmdc)])]`.  
<!--
```{r check singularity}
dmf[id == "b" & dm2 == "2", .(id, trend, dm2)]
```
-->

`r grepout("dm2[2-4]", allco[!allco %in% names(lmdc)])` are the dropped terms to avoid collinearity between `id`, `trend`, `dm2Y` for Y=2, ..., 4.

### Test estimation using divorce data

If we use `et` variable as the first regressor, it overparameterises and gives rise to multicollinearity. In such case, we need to drop one more event time manually.

<details><summary>Click here to see how reference period choice affects estimated results.</summary>
```{r baseline reference period comparison, warning = F}
summary(dv[, .(StateName, et, time, trend, trend2, trend3)])
obj = copy(dv)
#### In regression with no intercept,
#### lm keeps all levels in the 1st factor variable in the formula.
#### lm drops 1st levels in the 2nd factor variable in the formula.
#### lm drops 1st and last levels in the 3rd factor variable in the formula.
 #### event time, factors
r10a <- lm(v ~ -1+et+StateName+time, data = obj)
r10b <- lm(v ~ -1+StateName+et+time, data = obj)
r10c <- lm(v ~ -1+StateName+time+et, data = obj)
obj[, time := factor(time, 
    levels = c(1988, levels(time)[!(levels(time) %in% c(1988, 1959:1961))], 1961:1959))]
 #### event time, factors, trends
r22a <- lm(v ~ -1+et+trend+trend2+trend3+StateName+time, data = obj)
r22b <- lm(v ~ -1+trend+trend2+trend3+StateName+et+time, data = obj)
r22c <- lm(v ~ -1+trend+trend2+trend3+StateName+time+et, data = obj)
 #### Create a dummy matrix of factor variable "et"
etdumpre <- makeDummyFromFactor(factor(obj[, et]), nameprefix = "et")
setnames(etdumpre, grepout("-", colnames(etdumpre)), 
  gsub("-", "N", grepout("-", colnames(etdumpre))))
 #### Subtract t-L, L=10 period to impose \bar{gamma}_{s<0} = 0
negtime <- grepout("N", colnames(etdumpre))
etdumpre[, (negtime) := lapply(.SD, function(x) x-etN10), .SDcols = negtime]
etdumpre[, etN10 := NULL]
 #### formula terms for et dummy matrix
ettermspre <- paste(colnames(etdumpre), collapse = "+")
#obj[, StateName := factor(StateName, exclude=c('Hawaii', 'Florida', 'District Of Columbia'))]
obj3 <- data.table(obj, etdumpre)
 #### factors, trends, explicit event time dummies
form1 <- paste0("v ~ -1+StateName+time+", ettermspre)
form2 <- paste0("v ~ -1+trend+StateName+time+", ettermspre)
form3 <- paste0("v ~ -1+trend+trend2+trend3+StateName+time+", ettermspre)
r31 <- lm(as.formula(form1), data = obj3)
r32 <- lm(as.formula(form2), data = obj3)
r33 <- lm(as.formula(form3), data = obj3)
```
Compare r10a, r10b, r10c, r22a, r22b, r22c, r31, r32, r33.
```{r ci baseline normalization, warning = F}
#### explanation of forms
form0 <- c(
  #### r10
  "et+StateName+time", "StateName+et+time", "StateName+time+et",
  #### r22
  "et+trend+trend2+trend3+StateName+time",
  "trend+trend2+trend3+StateName+et+time",
  "trend+trend2+trend3+StateName+time+et",
  #### r3X
  "StateName+time+eterms",
  "trend+StateName+time+eterms",
  "trend+trend2+trend3+StateName+time+eterms")
#### explanation of term order
forder <- c(paste(rep(c("TWFE", "TWFE trend"), each = 3), 
  c("et pos 1", "et pos 2", "et pos last")), 
  "TWFE premean = 0", "TWFE trend premean = 0",
  "TWFE trend3 premean = 0")
#### explanation of normalization choice
 #### TWFE and TWFE trend use default normalization of factor level order
 #### r10a: all levels of et are used, r10b: first level of et is dropped, etc. 
 #### r31-r33: etN10 is dropped, r32-r33: time is dropped in favor of trend
normalization <- c(rep(c("TWFE", "TWFE trend"), each = 3), 
  rep("TWFE trend premean = 0", 3))
nums <- c(rep(c(10, 22), each =3), 31:33)
Ci <- NULL
for (i in 1:9) {
  if (i < 7) 
    rr <- get(paste0("r", nums[i], rep(letters[1:3], 2)[i])) else
    rr <- get(c("r31", "r32", "r33")[i-6])
  clus <- data.table(rr$model)[, StateName]
  rrc <- clx(rr, cluster = clus, returnV = T)
  clxci <- data.table(cbind(Coef = rownames(rrc$ci), rrc$est, rrc$ci))
  clxci <- rbind(clxci, t(c(-1, 0, rep(NA, 5))), use.names = F)
  clxci[, FormulaOrder := forder[i]]
  clxci[, normalisation := normalization[i]]
  Ci <- rbind(Ci, clxci)
}
Ci[, period := gsub("et", "", Coef)]
Ci <- Ci[grepl("^.?\\d", period), ]
Ci[, period := gsub("N", "-", period)]
Ci[, period := as.numeric(period)]
setcolorder(Ci,
 c("Coef", "Estimate", "Std. Error", "t value", "Pr(>|t|)", "2.5 %", "97.5 %", "period"))
setnames(Ci, c("Estimate", "2.5 %", "97.5 %"), c("beta", "CI_L", "CI_U"))
numcols <- c("beta", "CI_L", "CI_U", "period")
Ci[, (numcols) := lapply(.SD, as.numeric), .SDcols = numcols]
strcols <- colnames(Ci)[!(colnames(Ci) %in% numcols)]
Ci[, (strcols) := lapply(.SD, factor), .SDcols = strcols]
Ci[, FormulaOrder := factor(FormulaOrder, levels = forder)]
```
```{r plot compare ci, eval = T, echo = F, warning = F, fig.cap = "Impacts on divorce rates: Different normalization", fig.show = "hold", fig.fullwidth = T, out.width = "100%"}
ggplot(data = Ci, 
  aes(x = period, y = beta, group = FormulaOrder, 
    color = FormulaOrder, shape = FormulaOrder, fill = FormulaOrder)) + 
  geom_pointrange(aes(ymin = CI_L, ymax = CI_U), 
    size = .1, position = position_dodge(width = .2)) +
  geom_line() + ThisTheme +
  theme(
  legend.text=element_text(size=8),
  legend.key.size=unit(.5, "cm")
  ) +
  facet_wrap(~ normalisation, scales = "free_y")+
  scale_fill_viridis_d(end = .7)+
  scale_colour_viridis_d(end = .7)+
  scale_y_continuous(limits = c(-5, 10)) +
  scale_x_continuous(limits = c(-24.5, 10.5)) +
  geom_hline(yintercept = 0, colour = "green")
```
Compare `r paste0(c("r10a", "r10b", "r10c", "r22a", "r22b", "r22c", "r31", "r32", "r33"), "(", forder, ")")`.

 * r10a vs r10b, r10c: One sees that keeping all levels adds a value equivalent to the intercept to all estimates. This gives a problem when we force a normalisation $\gamma_{-1}=0$ as the estimates jump around $t=-1$. Another noticeable characteristic is that standard errors decrease as event time progresses. We also note that estimates on time dummies are of too large magnitude which may be due to the use of higher order trending terms. We may need to use only a linear trend.  
 * r22a vs. r22b, r22c: When et assumes the role of intercept (r22a), it has to counter the rapid decline caused by the trend, thence an increasing pattern of estimated values as time passes. This must be avoided. r22b and r22c drop et=-1 and et=15. All estimates of r22b and r22c are identical.  
 * r31: Only N10 is dropped. r32: N10 and time are dropped.  

If we exclude r10a and r22a, estimates are much similar.

```{r plot compare ci wo r10a r22a, eval = T, echo = F, warning = F, fig.cap = "Impacts on divorce rates: Different normalization with event time factor defined as deviation from overall mean", fig.show = "hold", fig.fullwidth = F, out.width = "100%"}
ggplot(data = Ci[!grepl("TWFE.*1", FormulaOrder), ], 
  aes(x = period, y = beta, group = FormulaOrder, 
    color = FormulaOrder, shape = FormulaOrder, fill = FormulaOrder)) + 
  geom_pointrange(aes(ymin = CI_L, ymax = CI_U), 
    size = .1, position = position_jitterdodge(dodge = .75)) +
  geom_line() + ThisTheme +
  theme(
  legend.text=element_text(size=8),
  legend.key.size=unit(.5, "cm")
  ) +
  scale_fill_viridis_d(end = .7)+
  scale_colour_viridis_d(end = .7)+
  scale_y_continuous() +
  scale_x_continuous(limits = c(-24.5, 10.5)) +
  geom_hline(yintercept = 0, colour = "green")
```

* Differences in point estimates are difference in normalization choice, t=-1 or premean = 0.  
* Such seemingly an inoccuous choice has big impacts on standard errors. Premean = 0 seems to enjoy tighter CIs.  

```{r plot compare ci only r3X, eval = T, echo = F, warning = F, fig.cap = "Impacts on divorce rates: Premean = 0 normalization", fig.show = "hold", fig.fullwidth = F, out.width = "100%"}
ggplot(data = Ci[grepl("pre", FormulaOrder), ], 
  aes(x = period, y = beta, group = FormulaOrder, 
    color = FormulaOrder, shape = FormulaOrder, fill = FormulaOrder)) + 
  geom_pointrange(aes(ymin = CI_L, ymax = CI_U), 
    size = .1, position = position_jitterdodge(dodge = .75)) +
  geom_line() + ThisTheme +
  theme(
  legend.text=element_text(size=8),
  legend.key.size=unit(.5, "cm")
  ) +
  scale_fill_viridis_d(end = .7)+
  scale_colour_viridis_d(end = .7)+
  scale_y_continuous() +
  scale_x_continuous(limits = c(-24.5, 10.5)) +
  geom_hline(yintercept = 0, colour = "green")
```

What if we only use 1961- and etN19-et15?  

```{r keep only 1961 onwards, warning = F}
obj = copy(dv)
r10a <- lm(v ~ -1+et+StateName+time, 
  data = obj[as.numeric(as.character(time)) > 1960, ])
r10b <- lm(v ~ -1+StateName+et+time, 
  data = obj[as.numeric(as.character(time)) > 1960, ])
r10c <- lm(v ~ -1+StateName+time+et, 
  data = obj[as.numeric(as.character(time)) > 1960, ])
r22a <- lm(v ~ -1+et+trend+trend2+trend3+StateName+time, 
  data = obj[as.numeric(as.character(time)) > 1960, ])
r22b <- lm(v ~ -1+trend+trend2+trend3+StateName+et+time, 
  data = obj[as.numeric(as.character(time)) > 1960, ])
r22c <- lm(v ~ -1+trend+trend2+trend3+StateName+time+et, 
  data = obj[as.numeric(as.character(time)) > 1960, ])
obj[, time := factor(time, 
    levels = c(1988, levels(time)[!(levels(time) %in% c(1988, 1959:1961))], 1961:1959))]
etdumpre <- makeDummyFromFactor(factor(obj[, et]), nameprefix = "et", reference = NULL)
setnames(etdumpre, grepout("-", colnames(etdumpre)), 
  gsub("-", "N", grepout("-", colnames(etdumpre))))
negtime <- grepout("N", colnames(etdumpre))
etdumpre[, (negtime) := lapply(.SD, function(x) x-etN10), .SDcols = negtime]
etdumpre[, etN10 := NULL]
ettermspre <- paste(colnames(etdumpre), collapse = "+")
obj3 <- data.table(obj, etdumpre)
ettermspre2 <- gsub("etN2..*etN20\\+", "", ettermspre)
form1 <- paste0("v ~ -1+StateName+time+", ettermspre2)
form2 <- paste0("v ~ -1+trend+StateName+time+", ettermspre2)
form3 <- paste0("v ~ -1+trend+trend2+trend3+StateName+time+", ettermspre2)
r31 <- lm(as.formula(form1), data = obj3[as.numeric(as.character(time)) > 1960, ])
r32 <- lm(as.formula(form2), data = obj3[as.numeric(as.character(time)) > 1960, ])
r33 <- lm(as.formula(form3), data = obj3[as.numeric(as.character(time)) > 1960, ])
Ci <- NULL
normalization <- c(rep(c("TWFE", "TWFE trend"), each = 3), 
  rep("TWFE trend premean = 0", 3))
nums <- c(rep(c(10, 22), each =3), 31:33)
Ci <- NULL
for (i in 1:9) {
  if (i < 7) 
    rr <- get(paste0("r", nums[i], rep(letters[1:3], 2)[i])) else
    rr <- get(c("r31", "r32", "r33")[i-6])
  clus <- data.table(rr$model)[, StateName]
  rrc <- clx(rr, cluster = clus, returnV = T)
  clxci <- data.table(cbind(Coef = rownames(rrc$ci), rrc$est, rrc$ci))
  if (i < 7) clxci <- rbind(clxci, t(c(-1, 0, rep(NA, 5))), use.names = F)
  clxci[, FormulaOrder := forder[i]]
  clxci[, normalisation := normalization[i]]
  Ci <- rbind(Ci, clxci)
}
Ci[, period := gsub("et", "", Coef)]
Ci <- Ci[grepl("^.?\\d|tre", period), ]
Ci[, period := gsub("N", "-", period)]
Ci[, period := as.numeric(period)]
setcolorder(Ci,
 c("Coef", "Estimate", "Std. Error", "t value", "Pr(>|t|)", "2.5 %", "97.5 %", "period"))
setnames(Ci, c("Estimate", "2.5 %", "97.5 %"), c("beta", "CI_L", "CI_U"))
numcols <- c("beta", "CI_L", "CI_U", "period")
Ci[, (numcols) := lapply(.SD, as.numeric), .SDcols = numcols]
strcols <- colnames(Ci)[!(colnames(Ci) %in% numcols)]
Ci[, (strcols) := lapply(.SD, factor), .SDcols = strcols]
Ci[, FormulaOrder := factor(FormulaOrder, levels = forder)]
Ci[grepl("pre", FormulaOrder) & abs(period) < 2, 
  .(Coef, beta, period, FormulaOrder)]
Ci[grepl("pre", FormulaOrder) & grepl("trend", Coef), 
  c("Coef", "beta", "Pr(>|t|)", "FormulaOrder")]
```
```{r plot compare ci only r3X post 1960, eval = T, echo = F, warning = F, fig.cap = "Impacts on divorce rates: Premean = 0 normalization, 1961-", fig.show = "hold", fig.fullwidth = F, out.width = "100%"}
ggplot(data = Ci[grepl("pre", FormulaOrder) , ], 
  aes(x = period, y = beta, group = FormulaOrder, 
    color = FormulaOrder, shape = FormulaOrder, fill = FormulaOrder)) + 
  geom_pointrange(aes(ymin = CI_L, ymax = CI_U), 
    size = .1, position = position_jitterdodge(dodge = .25)) +
  geom_line() + ThisTheme +
  theme(
  legend.text=element_text(size=8),
  legend.key.size=unit(.5, "cm")
  ) +
  scale_fill_viridis_d(end = .8)+
  scale_colour_viridis_d(end = .8)+
  scale_y_continuous(limits = c(-1.5, 3)) +
  scale_x_continuous(limits = c(-19.5, 14.5)) +
  geom_hline(yintercept = 0, colour = "green")
```

* Estimates are exactly the same for all models.   
* Trend and time FEs have a linear relationship. This makes estimates on other variables exactly the same.  
* When time FEs and trend are put together, $\tilde{\tau}_{1} = \tau_{1} - trend$, $\tilde{\tau}_{2} = \tau_{2} - 2*trend$, ... where $\tau_{t}$ is time $t$ FE in the regression without a trending term, and one of $\tilde{\tau}_{t}$ must drop to avoid collinearity with $trend$ and $\tau_{t}$.  

In essence, the only variations in estimation specification that are worths examining are TWFE with $t=-1$ being zero, TWFE premean = 0, both `et` being dropped of one of the factor levels.

```{r plot compare ci TWFE TWFE pre post 1960, eval = T, echo = F, warning = F, fig.cap = "Impacts on divorce rates: Premean = 0 normalization, 1961-", fig.show = "hold", fig.fullwidth = F, out.width = "100%"}
ggplot(data = Ci[grepl("TWFE et pos 2|E pre", FormulaOrder) , ], 
  aes(x = period, y = beta, group = FormulaOrder, 
    color = FormulaOrder, shape = FormulaOrder, fill = FormulaOrder)) + 
  geom_pointrange(aes(ymin = CI_L, ymax = CI_U), 
    size = .2, position = position_jitterdodge(dodge = .5)) +
  geom_line() + ThisTheme +
  theme(
  legend.text=element_text(size=8),
  legend.key.size=unit(.75, "cm")
  ) +
  scale_fill_viridis_d(end = .8)+
  scale_colour_viridis_d(end = .8)+
  scale_y_continuous(limits = c(-2, 2.75)) +
  scale_x_continuous(limits = c(-19.5, 14.5)) +
  geom_hline(yintercept = 0, colour = "green")
```

* It is essential to acknowledge an increasing trend in divorce rates in the data to understand the difference in estimates.  
* Restriction premean = 0 pulls down pre-period estimates. When combined with the increasing trend, it gives rise to elevated post-period estimates.  
* Dealing only with time FEs (or with an overall trend) stabilizes point estimates around zero, but at the cost of increasing SEs or a less precise fit.  
* With smaller SEs, one would choose the model with the premean = 0 restriction.  

There seems to be a pattern in SEs: They are smallest when the sign of estimates change (when the line cross zero). 

*Multiple factors with interactions and individual time trend*  


```{r with without state spec trends, warning = F}
obj = copy(dv)
obj[, et := factor(et)]
r22 <- lm(v ~ -1+trend*StateName+time+et, 
  data = obj[as.numeric(as.character(time)) > 1960, ])
obj[, time := factor(time, 
    levels = c(1988, levels(time)[!(levels(time) %in% c(1988, 1959:1961))], 1961:1959))]
etdumpre <- makeDummyFromFactor(factor(obj[, et]), nameprefix = "et", reference = NULL)
setnames(etdumpre, grepout("-", colnames(etdumpre)), 
  gsub("-", "N", grepout("-", colnames(etdumpre))))
negtime <- grepout("N", colnames(etdumpre))
etdumpre[, (negtime) := lapply(.SD, function(x) x-etN10), .SDcols = negtime]
etdumpre[, etN10 := NULL]
ettermspre <- paste(colnames(etdumpre), collapse = "+")
obj3 <- data.table(obj, etdumpre)
ettermspre2 <- gsub("etN2..*etN20\\+", "", ettermspre)
form2 <- paste0("v ~ -1+trend*StateName+time+", ettermspre2)
r32 <- lm(as.formula(form2), data = obj3[as.numeric(as.character(time)) > 1960, ])
Ci <- NULL
normalization <- c(rep(c("TWFE", "TWFE trend"), each = 3), 
  rep("TWFE trend premean = 0", 3))
nums <- c(rep(c(10, 22), each =3), 31:33)
Ci <- NULL
for (i in 1:9) {
  if (i < 7) 
    rr <- get(paste0("r", nums[i], rep(letters[1:3], 2)[i])) else
    rr <- get(c("r31", "r32", "r33")[i-6])
  clus <- data.table(rr$model)[, StateName]
  rrc <- clx(rr, cluster = clus, returnV = T)
  clxci <- data.table(cbind(Coef = rownames(rrc$ci), rrc$est, rrc$ci))
  if (i < 7) clxci <- rbind(clxci, t(c(-1, 0, rep(NA, 5))), use.names = F)
  clxci[, FormulaOrder := forder[i]]
  clxci[, normalisation := normalization[i]]
  clxci[, spec := paste0("r", 
    c("10a", "10b", "10c", "22a", "22", "23c", "31", "32", "33")[i])]
  Ci <- rbind(Ci, clxci)
}
Ci[, period := gsub("et", "", Coef)]
Ci <- Ci[grepl("^.?\\d|tre", period), ]
Ci[, period := gsub("N", "-", period)]
Ci[, period := as.numeric(period)]
setcolorder(Ci,
 c("Coef", "Estimate", "Std. Error", "t value", "Pr(>|t|)", "2.5 %", "97.5 %", "period"))
setnames(Ci, c("Estimate", "2.5 %", "97.5 %"), c("beta", "CI_L", "CI_U"))
numcols <- c("beta", "CI_L", "CI_U", "period")
Ci[, (numcols) := lapply(.SD, as.numeric), .SDcols = numcols]
strcols <- colnames(Ci)[!(colnames(Ci) %in% numcols)]
Ci[, (strcols) := lapply(.SD, factor), .SDcols = strcols]
Ci[, FormulaOrder := factor(FormulaOrder, levels = forder)]
Ci[grepl("22$|32", spec), FormulaOrder := gsub("trend", "itrend", FormulaOrder)]
Ci[grepl("22$|32", spec) & (abs(period) < 2 | grepl("trend$", Coef)), 
  c("Coef", "beta", "Pr(>|t|)", "spec", "FormulaOrder")]
```
```{r plot indiv trend, eval = T, echo = F, warning = F, fig.cap = "Impacts on divorce rates: State specific trends", fig.show = "hold", fig.fullwidth = F, out.width = "100%"}
ggplot(data = Ci[grepl("22$|32", spec), ], 
  aes(x = period, y = beta, group = FormulaOrder, 
    color = FormulaOrder, shape = FormulaOrder, fill = FormulaOrder)) + 
  geom_pointrange(aes(ymin = CI_L, ymax = CI_U), 
    size = .2, position = position_jitterdodge(dodge = .5)) +
  geom_line() + ThisTheme +
  theme(
  legend.text=element_text(size=8),
  legend.key.size=unit(.75, "cm")
  ) +
  scale_fill_viridis_d(end = .8)+
  scale_colour_viridis_d(end = .8)+
  scale_y_continuous(limits = c(-20, 5)) +
  scale_x_continuous(limits = c(-19.5, 14.5)) +
  geom_hline(yintercept = 0, colour = "green")
```

* Estimates under premean = 0 with state specific trends are not sensible.  
* Restrict et to be between -15 and 10.  


```{r with without state spec trends et N15 10, warning = F}
#### Restrict: -15 <= et <= 10
obj = copy(dv)
table(obj[as.numeric(as.character(time)) > 1960, et])
obj1 = copy(dv)
obj1[, time := factor(time, 
    levels = c(1988, levels(time)[!(levels(time) %in% c(1988, 1959:1961))], 1961:1959))]
obj1[, et := as.numeric(as.character(et))]
#### et < -15 | et > 10 ==> -1, so it does not directly affect et estimates
obj1[et < -15 | et > 10, et := -1L]
obj1[, et := factor(et)]
obj1[, et := factor(et, levels = c(-1, levels(et)[!(levels(et) %in% c(-1))]))]
#### r10bb: TWFE with et restriction
r10bb <- lm(v ~ -1+StateName+time+et, 
  data = obj1[as.numeric(as.character(time)) > 1960, ])
#### r22: TWFE with indiv trends and et restriction
r22 <- lm(v ~ -1+trend*StateName+time+et, 
  data = obj1[as.numeric(as.character(time)) > 1960, ])
#### Explicitly drop etN16, etN17, ..., et11, et12, and allow etN1 to be kept
etdumpre <- makeDummyFromFactor(factor(obj[, et]), nameprefix = "et", reference = NULL)
setnames(etdumpre, grepout("-", colnames(etdumpre)), 
  gsub("-", "N", grepout("-", colnames(etdumpre))))
#### Drop et < -15 | et > 10 terms
etdumpre[, grepout("N2.|N1[6-9]|et1[1-9]", colnames(etdumpre)) := NULL]
ettermspre <- paste(colnames(etdumpre), collapse = "+")
obj3 <- data.table(obj1, etdumpre)
form2 <- paste0("v ~ -1+trend*StateName+time+", ettermspre)
#### r22e: TWFE with indiv trends, et restriction, keeping N1
r22e <- lm(as.formula(form2), data = obj3[as.numeric(as.character(time)) > 1960, ])
#### Explicitly drop et < -15 | et > 10 terms and drop etN1
etdumpre[, etN1 := NULL]
ettermspre <- paste(colnames(etdumpre), collapse = "+")
obj3 <- data.table(obj1, etdumpre)
form2 <- paste0("v ~ -1+trend*StateName+time+", ettermspre)
#### r22ee: TWFE with indiv trends, et restriction, dropping N1
r22ee <- lm(as.formula(form2), data = obj3[as.numeric(as.character(time)) > 1960, ])
#### Add "TWFE itrend N15P10" to forder, paste N15P10 to r22
forder2 <- c(forder, "TWFE itrend N15P10", "TWFE itrend no N1 N15P10")
forder2 <- gsub("i?trend et pos 2", "itrend et pos 2 N15P10", forder2)
forder2 <- gsub("E et pos 2", "E et pos 2 N15P10", forder2)
regob <- paste0("r", c("10a", "10bb", "10c", 
    "22a", "22", "22c", "31", "32", "33", "22e", "22ee"))
Ci <- NULL
for (i in 1:length(regob)) {
  rr <- get(regob[i])
  clus <- data.table(rr$model)[, StateName]
  rrc <- clx(rr, cluster = clus, returnV = T)
  clxci <- data.table(cbind(Coef = rownames(rrc$ci), rrc$est, rrc$ci))
  if (i < 7) clxci <- rbind(clxci, t(c(-1, 0, rep(NA, 5))), use.names = F)
  clxci[, FormulaOrder := forder2[i]]
  clxci[, spec := regob[i]]
  Ci <- rbind(Ci, clxci)
}
Ci[, period := gsub("et", "", Coef)]
Ci <- Ci[grepl("^.?\\d|tre", period), ]
Ci[, period := gsub("N", "-", period)]
Ci[, period := as.numeric(period)]
setcolorder(Ci,
 c("Coef", "Estimate", "Std. Error", "t value", "Pr(>|t|)", "2.5 %", "97.5 %", "period"))
setnames(Ci, c("Estimate", "2.5 %", "97.5 %"), c("beta", "CI_L", "CI_U"))
numcols <- c("beta", "CI_L", "CI_U", "period")
Ci[, (numcols) := lapply(.SD, as.numeric), .SDcols = numcols]
strcols <- colnames(Ci)[!(colnames(Ci) %in% numcols)]
Ci[, (strcols) := lapply(.SD, factor), .SDcols = strcols]
Ci[, FormulaOrder := factor(FormulaOrder, levels = forder2)]
Ci[grepl("10bb|22$|22e", spec) & (abs(period) < 2 | grepl("trend$", Coef)), 
  c("Coef", "beta", "Pr(>|t|)", "spec", "FormulaOrder")]
```

```{r plot with without indiv trend, eval = T, echo = F, warning = F, fig.cap = "Impacts on divorce rates (event time in -15 to 10, observation 1961 - 1987): With or without state specific trends, keeping or dropping et=-1", fig.show = "hold", fig.fullwidth = F, out.width = "100%"}
ggplot(data = Ci[grepl("10bb|22$|22e", spec), ], 
  aes(x = period, y = beta, group = FormulaOrder, 
    color = FormulaOrder, shape = FormulaOrder, fill = FormulaOrder)) + 
  geom_pointrange(aes(ymin = CI_L, ymax = CI_U), 
    size = .2, position = position_jitterdodge(dodge = .5)) +
  geom_line() + ThisTheme +
  theme(
  legend.text=element_text(size=8),
  legend.key.size=unit(.75, "cm")
  ) +
  scale_fill_viridis_d(end = .8)+
  scale_colour_viridis_d(end = .8)+
  scale_y_continuous(limits = c(-1, 2)) +
  scale_x_continuous(limits = c(-15.5, 10.5)) +
  geom_hline(yintercept = 0, colour = "green")
```

* TWFE estimates with state specific trends may not look similar, but it is all due to the choice of normalisation.  
* State specific trends and dropping et = -1 (`r grepout("itrend et.*P", forder2)` estimated using a factor  and `r grepout("itrend No N", forder2)` estimated with an explicit dummy matrix) give identical estimates. When we drop et values outside [-15, 10] window and allow et = -1 to be used as a regressor, one gets estimates that are pushed upwards as in `r grepout("itrend N15", forder2)`.  
* Effects of different normalization/restriction in the choice of reference year are most pronounced near et=-1, or the choice in TWFE model. The contrasting model, TWFE with individual trends with zero set outside [-15, 10] window, has similar estimates around the edge of the window, which gives rise to an inverse-U shape (could have been U shape if the deviation is negative).  
* Restricting et = -1 to be zero reduces SEs.   
* Estimates with state specific trends have smaller SEs.  
* All model estimates are not trending.  
* In the base TWFE estimates, States have individual intercepts, year 1987 is dropped from factor `time`, et=-1 is dropped and its estimate is assigned the value of zero in `et`. In TWFE with individual trends, the additional restrictions are: trend&ast;Hawaii is dropped.  TWFE with individual trends and restricting et = -1 to be zero, additional retstriction is et = -1.  

</details>


So the general idea for normalisation is:

* Manually drop -1 from `et` if normalization $\gamma_{-1}=0$ is used.  
* Manually drop $-L$  from `et` if normalization $\bar{\gamma}_{s<0}=0$ is used and use $-L$ as the period to be substituted, after setting $\textrm{et}_{t<0}=\textrm{et}_{t<0}-\textrm{et}_{-L}$.  
* Manually drop 2 periods (start and last periods of data) from `time` to incorporate time FE and a linear trend. One for a reference of own dummy variable, another to avoid collinearity with trend.  
* Manually drop 1 state ("Hawaii") from `StateName` to incorporate state FE with a restriction $\bar{a}=0$, after setting $a_{i}=a_{i}-a_{Hawaii}$.  


## Veryfying the code with simulated data

### Using Bacon data

```{r generate data}
#### https://lost-stats.github.io/Model_Estimation/Research_Design/event_study.html#r
  #### Load and prepare data
####dat = fread("https://raw.githubusercontent.com/LOST-STATS/
#####LOST-STATS.github.io/master/Model_Estimation/Data/Event_Study_DiD/
##### bacon_example.csv") 
dat <- fread(paste0(pathsource, "bacon_example.csv"))
  #### Let's create a more user-friendly indicator of which states received treatment
dat[, treat := ifelse(is.na(`_nfd`), 0, 1)]
dat[, time_to_treat := ifelse(treat==1, year - `_nfd`, 0)]
```
`fixest` has `i` function that deals with interaction terms. By default, reference is the first level. Here, -1 is chosen explicitly.
```{r bacon fixest}
library(fixest)
twfe1 = feols(asmrs ~ i(time_to_treat, treat, ref = -1) | 
     #### Our key interaction: time × treatment status
     stfips + year,      #### FEs
     cluster = ~stfips, #### Clustered SEs
     data = dat)
```
```{r bacon dummy matrix}
ttdum <- makeDummyFromFactor(factor(dat[, time_to_treat]), 
  nameprefix = "tt", reference = NULL)
setnames(ttdum, colnames(ttdum), gsub("-", "N", colnames(ttdum)))
ttterms <- paste(colnames(ttdum), collapse = "+")
ttterms2 <- gsub("\\+ttN1\\+", "+", ttterms) # ttN21+...+ttN2+tt0+tt1+...
ttterms3 <- gsub("ttN21\\+", "", ttterms) # ttN20+...+ttN1+tt0+tt1+...
dat[, time := factor(year)]
dat[, id := factor(stfips)]
dt <- data.table(dat, ttdum)
#### 2: no intercept+ttterms2, et=-1 is dropped
#### 3: with intercept+ttterms2, et=-1, id=1 are dropped
#### 4: with intercept+ttterms3, et=-21, id=1 are dropped
twfe2 <- lm(as.formula(paste0("asmrs ~ -1+id+time+", ttterms2)), data = dt)
twfe3 <- lm(as.formula(paste0("asmrs ~ id+time+", ttterms2)), data = dt)
twfe4 <- lm(as.formula(paste0("asmrs ~ id+time+", ttterms3)), data = dt)
tc1 <- twfe1$coeff
names(tc1) <- gsub("ti.*::", "tt", names(tc1))
names(tc1) <- gsub(":treat", "", names(tc1))
names(tc1) <- gsub("-", "N", names(tc1))
for (i in 1:4) {
  if (i > 1) {
    tw <- get(paste0("twfe", i))
    tc <- tw$coeff
  } else tc <- tc1
  tc <- tc[grep("tt", names(tc))]
  tc <- data.table(spec = c("fixest", "no int, -1", "int, -1, id=1", "int, -21, id=1")[i], 
    coef = names(tc), val = tc)
  assign(paste0("tcf", i), tc)
}
tcf <- rbindlist(list(tcf1, tcf2, tcf3, tcf4))
tcf[, et := gsub("tt", "", coef)]
tcf[, et := gsub("N", "-", et)]
tcf[, et := as.numeric(et)]
tcf[et == -21, ]
tcf[et == -1, ]
```
```{r CIs fixest and others}
library(clubSandwich)
ci1 <- data.table(cbind(names(twfe1$coeff), twfe1$coeff, stats::confint(twfe1)))
ci2 <- lapply(list(twfe2, twfe3, twfe4), function(x) 
  clubSandwich::conf_int(x, vcov = "CR2", level = 0.95, 
  test = "Satterthwaite", cluster = dt[, id], coefs = "All", p_values = T))
ci22 <- lapply(ci2, function(x) data.table(x)[, c("Coef", "beta", "CI_L", "CI_U")])
ci22 <- lapply(ci22, function(x) x[grepl("tt", Coef), ])
ci22 <- lapply(ci22, function(x) x[, et := gsub("tt", "", Coef)])
ci22 <- lapply(ci22, function(x) x[, et := as.numeric(gsub("N", "-", et))])
ci22 <- lapply(1:length(ci22), function(i) ci22[[i]][, estmethod := i+1])
setnames(ci1, c("Coef", "beta", "CI_L", "CI_U"))
ci1[, et := gsub(".*::", "", Coef)]
ci1[, et := as.numeric(gsub(":treat", "", et))]
ci1[, estmethod := 1]
ci22 <- rbindlist(ci22)
ci <- rbindlist(list(ci1, ci22), use.names = T, fill = T)
ci[, estmethod := factor(estmethod, labels = c("fixest", "lm et=-1", "lm et=-1 id=1", "lm et=-21 id=1"))]
```
```{r plot fixest compare, echo = F, warning = F, fig.cap = "Parameter estimates: `fixest` and other specifications", fig.show = "hold", fig.fullwidth = F, out.width = "100%"}
ggplot(data = ci, 
  aes(x = et, y = beta, group = estmethod, color = estmethod, 
    shape = estmethod, fill = estmethod)) + 
  geom_pointrange(aes(ymin = CI_L, ymax = CI_U), 
    size = .3, position = position_jitterdodge(dodge = .5)) +
  geom_line() +   
  ThisTheme + theme(
    legend.text=element_text(size=10),
    legend.key.size=unit(.5, "cm")
  ) +
  scale_fill_viridis_d(end = .7)+
  scale_colour_viridis_d(end = .7)+
  scale_y_continuous(limits = c(-22, 50)) +
  scale_x_continuous(limits = c(-22, 28)) +
  geom_hline(yintercept = 0, colour = "green")
```
We see that `fixest`, "lm et=-1", "lm et=-1 id=1" are equivalent, "lm et=-21" gives the estimates with a pararell shift to the above, and with larger SEs.  


### Using Miller data


```{r compare fixest using miller data}
#### Set seed for reproducibility
set.seed(10103)
#### Function to generate data (Miller)
gendata <- function(ctrl, trends) 
{
  #### trends: Set of treatment timing. Format: "10 11" (treated at 10, 11)
  #### ctrl: Existence of never-treated units, 0 or 1
  #### Number of observations
  numobs <- 48
  #### Number of treated unit types
  treatedunittypes <- length(unlist(strsplit(trends, " ")))
  #### Determine the number of treated and untreated observations
  numtreatedobs <- round(numobs / (1 + ctrl))
  numuntreatedobs <- numobs - numtreatedobs
  #### Calculate the number of observations per treated unit type
  obspertype <- floor(numtreatedobs / treatedunittypes)
  #### Extract event dates from the trends argument
  eventdates <- as.numeric(strsplit(trends, " ")[[1]])
  #### Create data.table
  dt <- data.table(id = 1:numobs)
  #### Create treated indicator
  dt[, treated := id > numuntreatedobs]
  #### Initialize Ei
  dt[, Ei := as.numeric(NA)]
  #### Fill in Ei values based on treated unit types
  for (ii in 1:treatedunittypes) {
    start <- (ii - 1) * obspertype + numuntreatedobs + 1
    stop <- ii * obspertype + numuntreatedobs
    dt[start <= id & id <= stop, Ei := eventdates[ii]]
  }
  #### Fill in Ei value for the last treated unit type
  if (max(dt[, id]) > stop) dt[id > stop, Ei := eventdates[treatedunittypes]]
  #### Expand time periods
  dt <- dt[, .(treated, Ei, t = 1:20), by = id]
  #### Set key for sorting
  setkey(dt, id, t)
  #### Make variables that determine the DGP
  dt[, etime := t - Ei]  #### Event time
  dt[, TE := ifelse(etime >= 0, etime + 1, 0)]  #### Endless ramp function for treatment effect
  dt[is.na(Ei), TE := 0]
  dt[, Y0_pure := 0]  #### Simplest counterfactual
  #### Other counterfactuals (commented out)
  #### dt[, Y0_pure := 4 * treated + 0.3 * treated * t]  #### Treated have a pre-trend...
  #### dt[, Y0_pure := 4 * treated + 0.1 * treated * (t - 10) * (Ei - 9)]  #### Pre-trend based on Ei...
  dt[, eps := sqrt(0.2) * rnorm(n = .N)]
  dt[, actual := Y0_pure + TE * treated]
  dt[, y := actual + eps]  ####s Observed Y
  return(dt)
}
gendata2 <- function(ctrl, trends) #### Edited
{
  #### trends: number of groups with same treatment timing
  #### ctrl: number of never treated units
  #### Number of observations
  numobs <- 48
  #### Number of treated unit types
  treatedunittypes <- length(trends)
  #### Determine the number of treated and untreated observations
  numtreatedobs <- round(numobs * (1 - ctrl/numobs))
  numuntreatedobs <- numobs - numtreatedobs
  #### Calculate the number of observations per treated unit type
  obspertype <- floor(numtreatedobs / treatedunittypes)
  #### Extract event dates from the trends argument
  eventdates <- as.numeric(trends[[1]])
  #### Create data.table
  dt <- data.table(id = 1:numobs)
  #### Create treated indicator
  dt[, treated := id > numuntreatedobs]
  #### Initialize Ei
  dt[, Ei := 0L]
  #### Fill in Ei values based on treated unit types
  for (ii in 1:treatedunittypes) {
    start <- (ii - 1) * obspertype + numuntreatedobs + 1
    stop <- ii * obspertype + numuntreatedobs
    dt[start <= id & id <= stop, Ei := eventdates[ii]]
  }
  #### Fill in Ei value for the last treated unit type
  if (max(dt[, id]) > stop) dt[id > stop, Ei := eventdates[treatedunittypes]]
  #### Expand time periods
  dt <- dt[, .(treated, Ei, t = 1:20), by = id]
  #### Set key for sorting
  setkey(dt, id, t)
  #### Make variables that determine the DGP
  dt[, etime := t - Ei]  #### Event time

  #### Step function treatment effect
  #### dt[, TE := 1 * (etime >= 0)]  #### Commented out in Stata
  dt[, TE := (etime >= 0) * (etime + 1)]  #### Endless ramp function for treatment effect
  dt[is.na(Ei), TE := 0]
  ####dt[, TE := ifelse(etime >= 0, etime + 1, 0)]
  dt[, Y0_pure := 0]  #### Simplest counterfactual
  #### Other counterfactuals (commented out)
  #### dt[, Y0_pure := 4 * treated + 0.3 * treated * t]  #### Treated have a pre-trend...
  #### dt[, Y0_pure := 4 * treated + 0.1 * treated * (t - 10) * (Ei - 9)]  #### Pre-trend based on Ei...
  #### Error term
  dt[, eps := sqrt(0.2) * rnorm(.N)]
  #### Actual and observed outcome
  dt[, actual := Y0_pure + TE * treated]
  dt[, y := actual + eps]
  return(dt)
}
#### Run the gendata function
dt <- gendata2(ctrl=1, trends=10:11)
#### Create event time dummies and drop if all entries are zero
for (ii in 0:10) {
  dt[, paste("D_p", ii, sep = "") := as.integer(etime == ii)]
  dt[, paste("D_m", ii, sep = "") := as.integer(etime == -ii)]
  dropme <- mean(dt[, eval(parse(text=paste0("D_p", ii)))], na.rm = T) == 0
  if (dropme) {
    cat(paste0("D_p", ii), "dropped due to all zero among treated.\n")
    dt[, (paste("D_p", ii, sep = "")) := NULL]
  }
  dropme <- mean(dt[, eval(parse(text=paste0("D_m", ii)))], na.rm = T) == 0
  if (dropme) {
     cat(paste0("D_m", ii), "dropped due to all zero among treated.\n")
     dt[, (paste("D_m", ii, sep = "")) := NULL]
  }
}
dt[, D_m0 := NULL]  # Drop D_m0
dt[, group2 := Ei == 11]
dt[, trend_group2 := t * group2]
destat(dt, signif = 2)  # Display summary statistics
# Normalize event time -1 to be zero
dt[D_m1 == 1, D_m1 := 0L]
dat = copy(dt)
```
```{r fixest compare miller data with trend, eval = F}
#### Need to work on how Miller generated data, error: asmrs is missing

dat[, trend := 1:.N, by = id]
library(fixest)
twfet1 = feols(y ~ i(etime, treated, ref = -1) +
  i(t, ref = c(1, 20)) + trend | id,      #### FEs
  cluster = ~id, data = dat)
if (length(twfet1$collin.var) > 0) twfet1$collin.var
tdum <- makeDummyFromFactor(factor(dat[, t]), 
  reference = NULL, nameprefix = "y")
tterms <- paste(colnames(tdum), collapse = "+")
tterms2 <- gsub("y1\\+", "", tterms2)
tterms3 <- gsub("\\+y20", "", tterms2)
dt <- data.table(dat, tdum, ttdum)
#### 2: no intercept, drop et=-1 (ttterms2), y1 (tterms2)
#### 3: with intercept, drop et=21 (ttterms3), y1, y20 (tterms3)
#### 4: with intercept, drop et=-1 (ttterms2), y1, y20 (tterms3)
twfet2 <- lm(as.formula(paste0("asmrs ~ -1+id+trend+", ttterms2, "+", tterms2)), data = dt)
twfet3 <- lm(as.formula(paste0("asmrs ~ id+trend+", ttterms3, "+", tterms3)), data = dt)
twfet4 <- lm(as.formula(paste0("asmrs ~ id+trend+", ttterms2, "+", tterms3)), data = dt)
tc1 <- twfet1$coeff
names(tc1) <- gsub("ti.*::", "tt", names(tc1))
names(tc1) <- gsub(":treat", "", names(tc1))
names(tc1) <- gsub("-", "N", names(tc1))
for (i in 1:4) {
  if (i > 1) {
    tw <- get(paste0("twfet", i))
    tc <- tw$coeff
  } else tc <- tc1
  tc <- tc[grep("tt", names(tc))]
  tc <- data.table(spec = c("fixest", "no int, -1", "int, -21", "int, -1")[i], 
    coef = names(tc), val = tc)
  assign(paste0("tcf", i), tc)
}
tcf <- rbindlist(list(tcf1, tcf2, tcf3, tcf4))
tcf[, et := gsub("tt", "", coef)]
tcf[, et := gsub("N", "-", et)]
tcf[, et := as.numeric(et)]
tcf[et == -21, ]
tcf[et == -1, ]
```
```{r plot fixest compare miller with trend, eval = F, echo = F, warning = F, fig.cap = "Parameter estimates with trend: `fixest` and other specifications", fig.show = "hold", fig.fullwidth = F, out.width = "100%"}
ggplot(data = tcf, 
  aes(x = et, y = val, group = spec, color = spec, 
    shape = spec, fill = spec)) + 
  geom_point(size = 1.75, position = position_jitterdodge(dodge = .4)) +
  geom_line() +   
  ThisTheme + theme(
    legend.text=element_text(size=10),
    legend.key.size=unit(.5, "cm")
  ) +
  scale_fill_viridis_d(end = .7)+
  scale_colour_viridis_d(end = .7)+
  #scale_y_continuous(limits = c(-6, 5)) +
  scale_x_continuous(limits = c(-22, 28)) +
  geom_hline(yintercept = 0, colour = "green")
```



## Data preparation and estimation




We need to manually drop -1 (for baseline) or $-L=-10$ (for zero mean pre-period effects) from event time variables, Hawaii from State dummy variables (for linear independence), 1960, 1988 from time dummy variables (for accommodating a linear trend). In below, this is done by creating a dummy matrix from a factor variable and dropping the chosen reference. In using restrictions $\bar{\gamma}_{s<0}=0$ or $\bar{a}_{i}=0$, we will subtract the chosen reference from each columns of a dummy matrix. 
```{r baseline estimation, warning = F}
for (ob in c("mr", "dv")) {
  obj <- qread(paste0(pathsave, ob, ".qs"))
  obj <- obj[, time2 := as.numeric(time)]
  obj <- obj[time2 >= 1960 & time2 <= 1988, ]
  #### State dummies
  stdum <- makeDummyFromFactor(factor(obj[, StateName]), nameprefix = "")
    #### Subtract Hawaii to impose \bar{a}_{i} = 0
  stnames <- colnames(stdum)
  setnames(stdum, stnames, gsub(" ", "", stnames))
  stdum[, (stnames) := lapply(.SD, function(x) x-Hawaii), .SDcols = stnames]
  stdum[, Hawaii := NULL]
  stterms <- paste(colnames(stdum), collapse = "+")
  #### Time dummies
  tdum <- makeDummyFromFactor(factor(obj[, time]), nameprefix = "y")
    #### Drop 1961, 1987 for accommodating trend and keep linear independence
  setnames(tdum, colnames(tdum), gsub("19", "", colnames(tdum)))
  tnames <- colnames(tdum)
  tdum[, paste0("y", c(61, 87)) := NULL]
  tterms <- paste(colnames(tdum), collapse = "+")
  etdum <- makeDummyFromFactor(factor(obj[, et]), nameprefix = "et")
  #### Event time dummies
    #### change to easier-to-handle names
  setnames(etdum, grepout("-", colnames(etdum)), 
    gsub("-", "N", grepout("-", colnames(etdum))))
  etdumpre = copy(etdum)
  etprepost = copy(etdum)
    #### Subtract t=-L, L=10 period to impose \bar{gamma}_{s<0} = 0
  negtime <- grepout("N", colnames(etdum))
  etdumpre[, (negtime) := lapply(.SD, function(x) x-etN10), .SDcols = negtime]
  etdumpre[, etN10 := NULL]
    #### Subtract t=-1 period to impose 
    #### \bar{gamma}_{0} = 0, \gamma_{s\neq 0}=\gamma_{s}-\gamma_{0}
  preposttime <- colnames(etdum)
  etprepost[, (preposttime) := lapply(.SD, function(x) x-etN1), 
    .SDcols = preposttime]
  etterms <- paste(colnames(etdum), collapse = "+")
    #### Drop -1 and -10 from et
  etterms1 <- gsub("\\+etN1\\+", "+", etterms)
  etterms2 <- gsub("\\+etN10", "", etterms)
  obj1 <- data.table(obj, stdum, tdum, etdum)
  obj1a <- data.table(obj, stdum, tdum, etprepost)
  obj2 <- data.table(obj, stdum, tdum, etdumpre)
    #### A: TWFE, B: TWFE+trend
  formA. <- paste0("v ~ -1+", stterms, " + ", tterms)
  formB. <- paste0("v ~ -1 + trend +", stterms, " + ", tterms)
  formC. <- paste0("v ~ -1 + trend + I(trend^(2)) + I(trend^(3))+", 
    stterms, " + ", tterms)
  formA1 <- paste(formA., "+", etterms1)
  formB1 <- paste(formB., "+", etterms1)
  formC1 <- paste(formC., "+", etterms1)
  formA2 <- paste(formA., "+", etterms2)
  formB2 <- paste(formB., "+", etterms2)
  formC2 <- paste(formC., "+", etterms2)
  obj1[, id := 1:.N]
  obj2[, id := 1:.N]
  rA0 <- lm(as.formula(formA.), data = obj1)
  rB0 <- lm(as.formula(formB.), data = obj1)
  rC0 <- lm(as.formula(formC.), data = obj1)
  rA1 <- lm(as.formula(formA1), data = obj1)
  rB1 <- lm(as.formula(formB1), data = obj1)
  rC1 <- lm(as.formula(formC1), data = obj1)
  rA2 <- lm(as.formula(formA2), data = obj2)
  rB2 <- lm(as.formula(formB2), data = obj2)
  rC2 <- lm(as.formula(formC2), data = obj2)
  #### All coefficients are relative to t=-1 (which is set to zero)
  rA0a <- lm(as.formula(formA.), data = obj1a)
  rB0a <- lm(as.formula(formB.), data = obj1a)
  rC0a <- lm(as.formula(formC.), data = obj1a)
  rA1a <- lm(as.formula(formA1), data = obj1a)
  rB1a <- lm(as.formula(formB1), data = obj1a)
  rC1a <- lm(as.formula(formC1), data = obj1a)
  assign(paste0(ob, "reg"), list(
    "TWFE"=rA0, "TWFE+t"=rB0, "TWFE+t3"=rC0, 
    "TWFE+et"=rA1, "TWFE+t+et"=rB1, "TWFE+t3+et"=rC1, 
    "TWFEa"=rA0a, "TWFEa+t"=rB0a, "TWFEa+t3"=rC0a, 
    "TWFEa+et"=rA1a, "TWFEa+t+et"=rB1a, "TWFEa+t3+et"=rC1a, 
    "TWFE+et, pre-period"=rA2, "TWFE+t+et, pre-period"=rB2,
    "TWFE+t3+et, pre-period"=rC2
    ))
  #### CI
  normalizationABC <- c("TWFE", "TWFE trend", "TWFE trend3")
  normalization123 <- c("no et", "-1", "pre-mean=0")
  Ci <- NULL
  for (ch in 1:3) {
    for (i in 0:2) {
      for (j in c("", "a")) {
        if (i==2 & j == "a") next
        rr <- get(paste0("r", LETTERS[ch], i, j))
        id <- as.numeric(names(rr$resid))
        clus <- obj1[id, StateName]
        #clus <- data.table(rr$model)[, StateName]
        rrc <- clx(rr, cluster = clus, returnV = T)
        clxci <- data.table(cbind(Coef = rownames(rrc$ci), rrc$est, rrc$ci))
        clxci[, normalABC := gsub("FE", paste0("FE", j), normalizationABC[ch])]
        clxci[, normal123 := normalization123[i+1]]
        Ci <- rbind(Ci, clxci)
      }
    }
  }
  Ci[, period := gsub("et", "", Coef)]
  Ci <- Ci[grepl("^.?\\d", period), ]
  Ci[, period := gsub("N", "-", period)]
  Ci[, period := as.numeric(period)]
  setcolorder(Ci, c("Coef", "Estimate", "Std. Error", "t value", "Pr(>|t|)", 
    "2.5 %", "97.5 %", "period"))
  setnames(Ci, c("Estimate", "2.5 %", "97.5 %"), c("beta", "CI_L", "CI_U"))
  numcols <- c("beta", "CI_L", "CI_U", "period", "Std. Error", "t value", "Pr(>|t|)")
  Ci[, (numcols) := lapply(.SD, as.numeric), .SDcols = numcols]
  strcols <- colnames(Ci)[!(colnames(Ci) %in% numcols)]
  Ci[, (strcols) := lapply(.SD, factor), .SDcols = strcols]
  Ci[grepl("mea", normal123) & period < 0, mean(beta), by = normalABC]
  qsave(Ci, paste0(pathsave, ob, "ci.qs"))
}
```


Trend terms:
```{r trend terms table}
library(modelsummary)
Results <- list("Divorce rates"=dvreg, "Marriage rates"=mrreg)
ii <- as.vector(which(unlist(lapply(dvreg, 
  function(x) any(grepl("tre", names(coef(x))))))))
ii <- ii[ii > 3]
res <- c(Results[[1]][ii], Results[[2]][ii])
ms <- modelsummary(res, 
  ####output = "gt",
  output = "kableExtra",
  stars = TRUE, 
  title = "Trend terms in two-way FEs of event study estimates",
  ####coef_omit = "Sta|time|^et.?[123][1-9]|[23]0",
  #### Need single quotes, double quotes give an error
  coef_map = c('trend' = 'Linear trend $t$', 'I(trend^(2))' = 'Squared trend $t^{2}$', 
    'I(trend^(3))' = 'Cubic trend $t^{3}$'),
  gof_omit = 'IC|Adj|F|RMSE|Log')
#### column labels	
###library(gt)
###ms <- tab_spanner(data = ms, label = 'Divorce rates', columns = 2:6)
###ms <- tab_spanner(data = ms, label = 'Marriage rates', columns = 7:11)
library(kableExtra)
ms <- add_header_above(ms, c(" " = 1, "Divorce rates" = 8, "Marriage rates" = 8))
kable_styling(ms, bootstrap_options = "striped", full_width = F, position = "left")
```


```{r plot div reg, echo = F, warning = F, fig.cap = "Impacts on divorce rates", fig.show = "hold", fig.fullwidth = F, out.width = "100%"}
Ci <- qread(paste0(pathsave, "dvci.qs"))
ggplot(data = Ci, 
  aes(x = period, y = beta, group = normal123, 
    color = normal123, shape = normal123, fill = normal123)) + 
  geom_pointrange(aes(ymin = CI_L, ymax = CI_U), 
    size = .3, position = position_jitterdodge(dodge = .2)) +
  #geom_line() +   
  ThisTheme +
  facet_wrap( ~ normalABC) +
  scale_fill_viridis_d(end = .7)+
  scale_colour_viridis_d(end = .7)+
  scale_y_continuous(limits = c(-6, 5)) +
  scale_x_continuous(limits = c(-20, 10)) +
  geom_hline(yintercept = 0, colour = "green")
```
```{r plot mar reg, echo = F, warning = F, fig.cap = "Impacts on marriage rates", fig.show = "hold", fig.fullwidth = F, out.width = "100%"}
Ci <- qread(paste0(pathsave, "mrci.qs"))
ggplot(data = Ci, 
  aes(x = period, y = beta, group = normal123, 
    color = normal123, shape = normal123, fill = normal123)) + 
  geom_pointrange(aes(ymin = CI_L, ymax = CI_U), 
    size = .3, position = position_jitterdodge(dodge = .2)) +
  #geom_line() +   
  ThisTheme +
  facet_wrap( ~ normalABC) +
  scale_fill_viridis_d(end = .7)+
  scale_colour_viridis_d(end = .7)+
  scale_y_continuous(limits = c(-10, 10)) +
  scale_x_continuous(limits = c(-20, 10)) +
  geom_hline(yintercept = 0, colour = "green")
```
```{r plot divorce reg2, eval = F, echo = F, warning = F, fig.cap = "Impacts on divorce rates (standardized with overall std and period mean of 1961-65)", fig.show = "hold", fig.fullwidth = F, out.width = "100%"}
dci <- qread(paste0(pathsave, "dci.qs"))
dci2 <- dci[grepl("-1|mean", normalization) & grepl("^e", spec), ]
dci2 <- dci2[!(grepl("mean", normalization) & beta == 0), ]
dci2[, ms := paste(method, spec)]
ggplot(data = dci2, 
  aes(x = period, y = beta, group = ms, color = ms, shape = ms, fill = ms)) + 
  geom_pointrange(aes(ymin = CI_L, ymax = CI_U), 
    size = .3, position = position_jitterdodge(dodge = .75)) +
  geom_line() +   ThisTheme +
  facet_wrap( ~ normalization)+
  scale_fill_viridis_d(end = .7)+
  scale_colour_viridis_d(end = .7)+
  scale_y_continuous(limits = c(-1, 5)) +
  scale_x_continuous(limits = c(-10, 10)) +
  geom_hline(yintercept = 0, colour = "green")
```

```{r estimation controlling only pre-period trend, eval = F, echo = F, warning = F}
for (ob in c("mr", "dv")) {
  obj = copy(get(ob))
  r00 <- lm(vs ~ -1+StateName+time, data = obj)
  r01 <- lm(vs ~ -1+ptrend+ptrend2+ptrend3+StateName, data = obj)
  r02 <- lm(vs ~ -1+ptrend+ptrend2+ptrend3+StateName+time, data = obj)
  r03 <- lm(vs ~ -1+ptrend*StateName+ptrend2*StateName+ptrend3*StateName+time, data = obj)
  r10 <- lm(vs ~ -1+et+StateName+time, data = obj)
  r11 <- lm(vs ~ -1+et+ptrend+ptrend2+ptrend3+StateName, data = obj)
  r12 <- lm(vs ~ -1+et+ptrend+ptrend2+ptrend3+StateName+time, data = obj)
  r13 <- lm(vs ~ -1+et+ptrend*StateName+ptrend2*StateName+ptrend3*StateName+time, data = obj)
  assign(paste0(ob, "regp"), list(
    "state+yr"=r00, 
    "pt+state"=r01, 
    "pt+state+yr"=r02, 
    "t*state+yr"=r03, 
    "et+state+yr"=r10, 
    "et+pt+state"=r11, 
    "et+pt+state+yr"=r12, 
    "et+pt*state+yr"=r13))
}
```
```{r reference-period-is-entire-pre-period estimation, eval = F, echo = F, warning = F}
for (ob in c("mr", "dv")) {
  obj = copy(get(ob))
  etobj <- get(paste0(ob, "et"))
  etterms <- paste(colnames(etobj), collapse = "+")
  obj2 <- data.table(obj, etobj)
  form.0 <- "v~-1+StateName"
  form01 <- form.2 <- "v~-1+trend+trend2+trend3+StateName"
  form.3 <- "v~-1+trend*StateName+trend2*StateName+trend3*StateName"
  for (i in c(0, 2:3)) 
    assign(paste0("form0", i), paste0(get(paste0("form.", i)), "+time"))
  for (i in 0:3) 
    assign(paste0("form1", i), paste0(get(paste0("form0", i)), "+", etterms))
  for (i in c("00", "01", "02", "03", 10:13)) 
    assign(paste0("r", i), lm(as.formula(get(paste0("form", i))), data = obj2))
  assign(paste0(ob, "regpmean"), list(
    "state+yr"=r00, 
    "t+state"=r01, 
    "t+state+yr"=r02, 
    "t*state+yr"=r03, 
    "et+state+yr"=r10, 
    "et+t+state"=r11, 
    "et+t+state+yr"=r12, 
    "et+t*state+yr"=r13))
}
```

```{r ci, eval = F, echo = F, warning = F, message = F}
#### cluster robust CI
library(clubSandwich)
spec4 <- c("TWFE", "State Trend", "TWFE Trend", "Year State*Trend")
Specs <- c(spec4, paste("e", spec4))
for (dm in 1:2) {
  CItr <- NULL
  for (tr in 1:3) {
    specs <- Specs
    if (tr == 2) specs <- gsub("Trend", "PreTrend", specs)
    CIm <- NULL
    for (m in 1:8) {
      rr <- get(paste0(c("dv", "mr")[dm], "reg", c("", "p", "pmean")[tr]))[[m]]
      clus <- data.table(rr$model)[, StateName]
      #### ci using clx
      rrc <- clx(rr, cluster = clus, returnV = T)
      clxci <- data.table(cbind(Coef = rownames(rrc$ci), rrc$est, rrc$ci))
      clxci <- rbind(clxci, t(c(-1, 0, rep(NA, 5))), use.names = F)
      #### ci using Pustejovsky and Tipton
      estres <- coef_test(rr, vcov = "CR2", cluster = clus, test = "Satterthwaite")
      ci <- conf_int(rr, vcov = "CR2", level = 0.95, 
        test = "Satterthwaite", cluster = clus, coefs = "All", p_values = T)
      assign(paste0(c("d", "m")[dm], c("", "p", "pmean")[tr], c("00", "01", "02", "03", 10:13)[m], "clx"), clxci)
      assign(paste0(c("d", "m")[dm], c("", "p", "pmean")[tr], c("00", "01", "02", "03", 10:13)[m], "est"), estres)
      assign(paste0(c("d", "m")[dm], c("", "p", "pmean")[tr], c("00", "01", "02", "03", 10:13)[m], "ci"), ci)
      if (m <= 4) next
      #### Trim estimates into tabular format to feed ggplot2
      Ci2 <- as.data.table(ci)
      Ci2 <- Ci2[grepl("^et", Coef), ]
      Ci2[, period := gsub("^et", "", Coef)]
      Ci2[, period := gsub("N", "-", period)]
      Ci2[, period := as.numeric(period)]
      setcolorder(Ci2,
        c("Coef", "beta", "SE", "df", "p_val", "CI_L", "CI_U", "period"))
      Ci2 <- rbind(Ci2, data.table(period = -1, beta = 0), use.names = T, fill = T)
      Ci2[, method := "Satterthwaite"]
      clxci[, period := gsub("et", "", Coef)]
      ci2 <- clxci[grepl("^.?\\d", period), ]
      ci2[, period := gsub("N", "-", period)]
      ci2[, period := as.numeric(period)]
      ci2[, method := "clx"]
      setcolorder(ci2,
       c("Coef", "Estimate", "Std. Error", "t value", "Pr(>|t|)", "2.5 %", "97.5 %", "period"))
      Ci2 <- rbind(Ci2, ci2, use.names = F)
      #### statistic: clx = t value, Satterthwaite = df
      setnames(Ci2, "df", "statistic")
      Ci2[, spec := specs[m]]
      assign(
        paste0(c("d", "m")[dm], c("", "p", "pmean")[tr], 
          c("00", "01", "02", "03", 10:13)[m], "ci2"), 
        Ci2)
####       setnames(ci2, 
####         grepout("be|S|df|CI|va", colnames(ci2)),
####         paste0("val.", grepout("be|S|df|CI|va", colnames(ci2))))
####       ci2L <- reshape(ci2, direction = "long", idvar = c("Coef", "period"),
####         varying = grepout("^va", colnames(ci2)))
####       setnames(ci2L, "time", "stat")  
####       setnames(ci2, 
####         grepout("^val", colnames(ci2)),
####         gsub("val.", "", grepout("^val", colnames(ci2))))
      CIm <- rbind(CIm, Ci2)
    }
    #### List of robust estimated result tables
    roblist <- list(
      get(paste0(c("d", "m")[dm], c("", "p", "pmean")[tr], "00est")), 
      get(paste0(c("d", "m")[dm], c("", "p", "pmean")[tr], "01est")), 
      get(paste0(c("d", "m")[dm], c("", "p", "pmean")[tr], "02est")), 
      get(paste0(c("d", "m")[dm], c("", "p", "pmean")[tr], "03est")), 
      get(paste0(c("d", "m")[dm], c("", "p", "pmean")[tr], "10est")), 
      get(paste0(c("d", "m")[dm], c("", "p", "pmean")[tr], "11est")), 
      get(paste0(c("d", "m")[dm], c("", "p", "pmean")[tr], "12est")), 
      get(paste0(c("d", "m")[dm], c("", "p", "pmean")[tr], "13est")))
    names(roblist) <- paste0(c("", "p", "pmean")[tr], 
      c("state+yr", "t+state", "t+state+yr", "t*state+yr", "state+yr+et", "t+state+et",
         "t+state+yr+et", "t*state+yr+et"))
    names(roblist) <- gsub("pstate", "state", names(roblist))
    assign(paste0(c("d", "m")[dm], c("", "p", "pmean")[tr], "rob"), roblist)
    CIm[, normalization := c("period -1=0", "control pre-trend", "pre-period mean=0")[tr]]
    CItr <- rbind(CItr, CIm)
  }
  numcols <- c("beta", "CI_L", "CI_U", "statistic", "p_val", "SE", "period")
  CItr[, (numcols) := lapply(.SD, as.numeric), .SDcols = numcols]
  strcols <- colnames(CItr)[!(colnames(CItr) %in% numcols)]
  CItr[, (strcols) := lapply(.SD, factor), .SDcols = strcols]
  assign(paste0(c("d", "m")[dm], "ci"), CItr)
}
library(qs)
qsave(dci, paste0(pathsave, "dci.qs"))
qsave(mci, paste0(pathsave, "mci.qs"))
```
```{r model summary, echo = F, eval = F, warning = F}
library(modelsummary)
Results <- list("Divorce rates"=drob, "Marriage rates"=mrob)
ms <- modelsummary(c(Results[[1]], Results[[2]]), 
  ####output = "gt",
  output = "kableExtra",
  stars = TRUE, 
  title = "Two-way FEs with time trends event study estimates",
  ####coef_omit = "Sta|time|^et.?[123][1-9]|[23]0",
  coef_omit = "^et.?[123][1-9]|[23]0|5[0-9]|6[0-5]|^Sta.*[a-z]$",
  gof_omit = "IC|Adj|F|RMSE|Log")
#### column labels
###library(gt)
###ms <- tab_spanner(data = ms, label = 'Divorce rates', columns = 2:6)
###ms <- tab_spanner(data = ms, label = 'Marriage rates', columns = 7:11)
library(kableExtra)
ms <- add_header_above(ms, c(" " = 1, "Divorce rates" = 6, "Marriage rates" = 6))
kable_styling(ms, full_width = F, position = "left")
```

```{r plot divorce reg, eval = F, echo = F, warning = F, fig.cap = "Impacts on divorce rates (standardized with overall std and period mean of 1961-65)", fig.show = "hold", fig.fullwidth = F, out.width = "100%"}
dci <- qread(paste0(pathsave, "dci.qs"))
dci2 <- dci[grepl("-1|mean", normalization) & grepl("^e", spec), ]
dci2 <- dci2[!(grepl("mean", normalization) & beta == 0), ]
dci2[, ms := paste(method, spec)]
ggplot(data = dci2, 
  aes(x = period, y = beta, group = ms, color = ms, shape = ms, fill = ms)) + 
  geom_pointrange(aes(ymin = CI_L, ymax = CI_U), 
    size = .3, position = position_jitterdodge(dodge = .75)) +
  geom_line() +   ThisTheme +
  facet_wrap( ~ normalization)+
  scale_fill_viridis_d(end = .7)+
  scale_colour_viridis_d(end = .7)+
  scale_y_continuous(limits = c(-1, 5)) +
  scale_x_continuous(limits = c(-10, 10)) +
  geom_hline(yintercept = 0, colour = "green")
```
```{r plot marriage reg, eval = F, echo = F, warning = F, fig.cap = "Impacts on marriage rates (standardized with overall std and period mean of 1961-65)", fig.show = "hold", fig.fullwidth = F, out.width = "100%"}
m10dt <- data.table(m10ci2); 
m11dt <- data.table(m11ci2); mp11dt <- data.table(mp11ci2)
m12dt <- data.table(m12ci2); mp12dt <- data.table(mp12ci2)
m13dt <- data.table(m13ci2); mp13dt <- data.table(mp13ci2)
m10dt[, spec := "TWFE"]; 
m11dt[, spec := "State Trend"]; mp11dt[, spec := "State preTrend"]
m12dt[, spec := "TWFE Trend"]; mp12dt[, spec := "TWFE preTrend"]
m13dt[, spec := "Year State*Trend"]; mp13dt[, spec := "Year State*preTrend"]
mci <- rbindlist(list(m10dt, m11dt, m12dt, m13dt, mp11dt, mp12dt, mp13dt))
ggplot(data = mci, 
  aes(x = period, y = beta, group = spec, color = spec, shape = spec, fill = spec)) + 
  geom_pointrange(aes(ymin = CI_L, ymax = CI_U), 
    size = .3, position = position_jitterdodge(dodge = 1.2)) +
  geom_line() +   ThisTheme +
  scale_fill_viridis_d(end = .7)+
  scale_colour_viridis_d(end = .7)+
  scale_y_continuous(limits = c(-4, 4)) +
  scale_x_continuous(limits = c(-10, 10)) +
  geom_hline(yintercept = 0, colour = "green")
```
When trending terms (and their cubic terms) are included (and their interactions with state dummies in the richest specifications), event study estimates also tend to have trends similar to gross trends, declining in marriage rates. In the case of divorce rates, use of trend terms breaks down estimation and event study estimates have the magnitude of thousands. This suggests possible collinearity bewteen linear trend and the time-to-event variable. In below, I will use TWFE and + only squared linear trend. 

```{r marriage divorce rate reg, eval = F, echo = F}
m10 <- lm(vs ~ et+StateName+time, data = mr)
#m11 <- lm(vs ~ et+trend2+StateName+time, data = mr)
d10 <- lm(vs ~ et+StateName+time, data = dv)
#d11 <- lm(vs ~ et+trend2+StateName+time, data = dv)
library(clubSandwich)
CI2 <- NULL
for (dm in c("d", "m")) {
  for (m in 1) {
    rr <- get(paste0(dm, (10:11)[m]))
    clus <- data.table(rr$model)[, StateName]
    ci <- conf_int(rr, vcov = "CR2", level = 0.95, 
      test = "Satterthwaite", cluster = clus, coefs = "All", p_values = T)
    ci2 <- as.data.table(ci)
    ci2[, period := gsub("et", "", Coef)]
    ci2 <- ci2[grepl("^et", Coef), ]
    ci2[, period := as.numeric(period)]
    setnames(ci2, 
      grepout("be|S|df|CI|va", colnames(ci2)),
      paste0("val.", grepout("be|S|df|CI|va", colnames(ci2))))
    setnames(ci2, 
      grepout("^val", colnames(ci2)),
      gsub("val.", "", grepout("^val", colnames(ci2))))
    ci2 <- rbind(ci2, data.table(period = -1, beta = 0, CI_L = 0, CI_U = 0), use.names = T, fill = T)
    ci2[, outcome := paste0(dm, c("", "+trend")[m])]
    CI2 <- rbind(CI2, ci2)
  }
}
```
```{marginfigure}
This shows that dropping a linear trend takes away trending in event study estimates.
```
```{r plot divorce marriage reg, eval = F	, echo = F, warning = F, fig.cap = "TWFE event study impacts on gross divorce and marriage rates (as a fraction of population)", fig.show = "hold", fig.fullwidth = F, out.width = "100%"}
#### TWFE event study design
ggplot(data = CI2, 
  aes(x = period, y = beta, group = outcome, 
    color = outcome, shape = outcome, fill = outcome)) + 
  geom_pointrange(aes(ymin = CI_L, ymax = CI_U), 
    size = .4, position = position_dodge(width = .4)) +
  geom_line() +   ThisTheme +
  scale_fill_viridis_d(end = .7)+
  scale_colour_viridis_d(end = .7)+
  scale_y_continuous(limits = c(-4, 4)) +
  scale_x_continuous(limits = c(-10, 10)) +
  geom_hline(yintercept = 0, colour = "orange") +
  geom_vline(xintercept = -1, colour = "gray")
```

> _I can win an argument on any topic, against any opponent.
>  People know this, and steer clear of me at parties. Often,
>  as a sign of their great respect, they don't even invite me._
>
> `r quote_footer('--- Dave Barry')`

Marriage Registration Area was established in January, 1957. In 1959, 32 States and 4 other areas participated. 
Alabama, Alaska, California,
Connecticut, Delaware, Florida, Georgia, Idaho, Iowa,
Kansas, Kentucky, Louisiana, Maine, Maryland, Michigan,
Mississippi, Montana, Nebraska, New Hampshire, New Jersey, 
New York (excluding New York City), Ohio, Oregon,
Pennsylvania, Rhode Island, South Dakota, Tennessee, Utah,
Vermont, Virginia, Wisconsin, Wyoming, Hawaii, Puerto Rico, 
Virgin Islands, and the independent registration area of New Orleans.

Divorce Registration Area was established in January, 1958.

In 1959, the DRA included 17 States and 2 other areas:
Alabama, Alaska, Georgia, Idaho, Iowa, Kansas, Maryland,
Montana, Nebraska, Oregon, Pennsylvania, South Dakota,
Tennessee, Utah, Virginia, Wisconsin, Wyoming, Hawaii,
and the Virgin Islands. See page 24 of [**Vital Statistics of the United States, 1959, Volume 1**](https://www.cdc.gov/nchs/data/vsus/VSUS_1959_1.pdf)



```{r bib, include=FALSE}
#### create a bib file for the R packages used in this document
knitr::write_bib(x = "rmarkdown", file = paste0(path, 'seiro.bib'))
```

<script>
  $(".toggle").click(function() {
    $(this).toggleClass("open");
  });
</script>

